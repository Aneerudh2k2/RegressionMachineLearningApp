{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // Internal Imports\n\n\nimport { Component } from \"../component\";\nimport { DOMUtils } from \"../../services\";\nimport { CartesianOrientations, Events } from \"../../interfaces\";\nimport { Tools } from \"../../tools\"; // D3 Imports\n\nimport { mouse } from \"d3-selection\";\nvar THRESHOLD = 5;\n/** check if x is inside threshold area extents  */\n\nfunction pointIsWithinThreshold(dx, x) {\n  return dx > x - THRESHOLD && dx < x + THRESHOLD;\n}\n\nvar Ruler =\n/** @class */\nfunction (_super) {\n  __extends(Ruler, _super);\n\n  function Ruler() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = \"ruler\";\n    return _this;\n  }\n\n  Ruler.prototype.render = function () {\n    this.drawBackdrop();\n    this.addBackdropEventListeners();\n  };\n\n  Ruler.prototype.formatTooltipData = function (tooltipData) {\n    return tooltipData;\n  };\n\n  Ruler.prototype.showRuler = function (_a) {\n    var _this = this;\n\n    var x = _a[0],\n        y = _a[1];\n    var svg = this.parent;\n    var orientation = this.services.cartesianScales.getOrientation();\n    var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y : x;\n    var ruler = DOMUtils.appendOrSelect(svg, \"g.ruler\").attr(\"aria-label\", \"ruler\");\n    var rulerLine = DOMUtils.appendOrSelect(ruler, \"line.ruler-line\");\n    var dataPointElements = svg.selectAll(\"[role=graphics-symbol]\");\n    var displayData = this.model.getDisplayData();\n    var rangeScale = this.services.cartesianScales.getRangeScale();\n\n    var _b = rangeScale.range(),\n        yScaleEnd = _b[0],\n        yScaleStart = _b[1];\n\n    var pointsWithinLine = displayData.map(function (d) {\n      return {\n        domainValue: _this.services.cartesianScales.getDomainValue(d),\n        originalData: d\n      };\n    }).filter(function (d) {\n      return pointIsWithinThreshold(d.domainValue, mouseCoordinate);\n    });\n\n    if (this.pointsWithinLine && pointsWithinLine.length === this.pointsWithinLine.length && pointsWithinLine.map(function (point) {\n      return point.domainValue;\n    }).join() === this.pointsWithinLine.map(function (point) {\n      return point.domainValue;\n    }).join()) {\n      this.pointsWithinLine = pointsWithinLine;\n      return this.services.events.dispatchEvent(Events.Tooltip.MOVE, {\n        mousePosition: [x, y]\n      });\n    }\n\n    this.pointsWithinLine = pointsWithinLine;\n    /**\n     * Find matches, reduce is used instead of filter\n     * to only get elements which belong to the same axis coordinate\n     */\n\n    var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function (accum, currentValue) {\n      if (accum.length === 0) {\n        accum.push(currentValue);\n        return accum;\n      } // store the first element of the accumulator array to compare it with current element being processed\n\n\n      var sampleAccumValue = accum[0].domainValue;\n      var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);\n      var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);\n\n      if (distanceToCurrentValue > distanceToAccumValue) {\n        // if distance with current value is bigger than already existing value in the accumulator, skip current iteration\n        return accum;\n      } else if (distanceToCurrentValue < distanceToAccumValue) {\n        // currentValue data point is closer to mouse inside the threshold area, so reinstantiate array\n        accum = [currentValue];\n      } else {\n        // currentValue is equal to already stored values, which means there's another match on the same coordinate\n        accum.push(currentValue);\n      }\n\n      return accum;\n    }, []); // some data point match\n\n    if (dataPointsMatchingRulerLine.length > 0) {\n      var rangeIdentifier_1 = this.services.cartesianScales.getRangeIdentifier();\n      var tooltipData = dataPointsMatchingRulerLine.map(function (d) {\n        return d.originalData;\n      }).filter(function (d) {\n        var value = d[rangeIdentifier_1];\n        return value !== null && value !== undefined;\n      }); // get elements on which we should trigger mouse events\n\n      var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function (d) {\n        return d.domainValue;\n      });\n      var elementsToHighlight = dataPointElements.filter(function (d) {\n        var domainValue = _this.services.cartesianScales.getDomainValue(d);\n\n        return domainValuesMatchingRulerLine_1.includes(domainValue);\n      });\n      /** if we pass from a trigger area to another one\n       * mouseout on previous elements won't get dispatched\n       * so we need to do it manually\n       */\n\n      if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {\n        this.hideRuler();\n      }\n\n      elementsToHighlight.dispatch(\"mouseover\"); // set current hovered elements\n\n      this.elementsToHighlight = elementsToHighlight;\n      this.services.events.dispatchEvent(Events.Tooltip.SHOW, {\n        mousePosition: [x, y],\n        hoveredElement: rulerLine,\n        data: this.formatTooltipData(tooltipData)\n      });\n      ruler.attr(\"opacity\", 1); // line snaps to matching point\n\n      var sampleMatch = dataPointsMatchingRulerLine[0];\n\n      if (orientation === \"horizontal\") {\n        rulerLine.attr(\"x1\", yScaleStart).attr(\"x2\", yScaleEnd).attr(\"y1\", sampleMatch.domainValue).attr(\"y2\", sampleMatch.domainValue);\n      } else {\n        rulerLine.attr(\"y1\", yScaleStart).attr(\"y2\", yScaleEnd).attr(\"x1\", sampleMatch.domainValue).attr(\"x2\", sampleMatch.domainValue);\n      }\n    } else {\n      this.hideRuler();\n    }\n  };\n\n  Ruler.prototype.hideRuler = function () {\n    var svg = this.parent;\n    var ruler = DOMUtils.appendOrSelect(svg, \"g.ruler\");\n    var dataPointElements = svg.selectAll(\"[role=graphics-symbol]\");\n    dataPointElements.dispatch(\"mouseout\");\n    this.services.events.dispatchEvent(Events.Tooltip.HIDE);\n    ruler.attr(\"opacity\", 0);\n  };\n  /**\n   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.\n   */\n\n\n  Ruler.prototype.addBackdropEventListeners = function () {\n    var self = this;\n    var displayData = this.model.getDisplayData();\n\n    var mouseMoveCallback = function () {\n      var pos = mouse(self.parent.node());\n      self.showRuler(pos);\n    }; // Debounce mouseMoveCallback if there are more than 100 datapoints\n\n\n    if (displayData.length > 100) {\n      var debounceThreshold = displayData.length % 50 * 12.5;\n      mouseMoveCallback = Tools.debounceWithD3MousePosition(function () {\n        var mousePosition = this.mousePosition;\n        self.showRuler(mousePosition);\n      }, debounceThreshold, this.parent.node());\n    }\n\n    this.backdrop.on(\"mousemove mouseover\", mouseMoveCallback).on(\"mouseout\", this.hideRuler.bind(this));\n  };\n\n  Ruler.prototype.drawBackdrop = function () {\n    var svg = this.parent;\n    var mainXScale = this.services.cartesianScales.getMainXScale();\n    var mainYScale = this.services.cartesianScales.getMainYScale();\n\n    var _a = mainXScale.range(),\n        xScaleStart = _a[0],\n        xScaleEnd = _a[1];\n\n    var _b = mainYScale.range(),\n        yScaleEnd = _b[0],\n        yScaleStart = _b[1]; // Get height from the grid\n\n\n    this.backdrop = DOMUtils.appendOrSelect(svg, \"svg.chart-grid-backdrop\");\n    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, \"rect.chart-grid-backdrop\");\n    this.backdrop.merge(backdropRect).attr(\"x\", xScaleStart).attr(\"y\", yScaleStart).attr(\"width\", xScaleEnd - xScaleStart).attr(\"height\", yScaleEnd - yScaleStart).lower();\n    backdropRect.attr(\"width\", \"100%\").attr(\"height\", \"100%\");\n  };\n\n  return Ruler;\n}(Component);\n\nexport { Ruler };","map":{"version":3,"sources":["/Users/nicholasrenotte/Desktop/Regression/app/client/node_modules/@carbon/charts/components/axes/ruler.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Component","DOMUtils","CartesianOrientations","Events","Tools","mouse","THRESHOLD","pointIsWithinThreshold","dx","x","Ruler","_super","_this","apply","arguments","type","render","drawBackdrop","addBackdropEventListeners","formatTooltipData","tooltipData","showRuler","_a","y","svg","parent","orientation","services","cartesianScales","getOrientation","mouseCoordinate","HORIZONTAL","ruler","appendOrSelect","attr","rulerLine","dataPointElements","selectAll","displayData","model","getDisplayData","rangeScale","getRangeScale","_b","range","yScaleEnd","yScaleStart","pointsWithinLine","map","domainValue","getDomainValue","originalData","filter","length","point","join","events","dispatchEvent","Tooltip","MOVE","mousePosition","dataPointsMatchingRulerLine","reduce","accum","currentValue","push","sampleAccumValue","distanceToCurrentValue","Math","abs","distanceToAccumValue","rangeIdentifier_1","getRangeIdentifier","value","undefined","domainValuesMatchingRulerLine_1","elementsToHighlight","includes","size","isEqual","hideRuler","dispatch","SHOW","hoveredElement","data","sampleMatch","HIDE","self","mouseMoveCallback","pos","node","debounceThreshold","debounceWithD3MousePosition","backdrop","on","bind","mainXScale","getMainXScale","mainYScale","getMainYScale","xScaleStart","xScaleEnd","backdropRect","merge","lower"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// Internal Imports\nimport { Component } from \"../component\";\nimport { DOMUtils } from \"../../services\";\nimport { CartesianOrientations, Events } from \"../../interfaces\";\nimport { Tools } from \"../../tools\";\n// D3 Imports\nimport { mouse } from \"d3-selection\";\nvar THRESHOLD = 5;\n/** check if x is inside threshold area extents  */\nfunction pointIsWithinThreshold(dx, x) {\n    return dx > x - THRESHOLD && dx < x + THRESHOLD;\n}\nvar Ruler = /** @class */ (function (_super) {\n    __extends(Ruler, _super);\n    function Ruler() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = \"ruler\";\n        return _this;\n    }\n    Ruler.prototype.render = function () {\n        this.drawBackdrop();\n        this.addBackdropEventListeners();\n    };\n    Ruler.prototype.formatTooltipData = function (tooltipData) {\n        return tooltipData;\n    };\n    Ruler.prototype.showRuler = function (_a) {\n        var _this = this;\n        var x = _a[0], y = _a[1];\n        var svg = this.parent;\n        var orientation = this.services.cartesianScales.getOrientation();\n        var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y : x;\n        var ruler = DOMUtils.appendOrSelect(svg, \"g.ruler\").attr(\"aria-label\", \"ruler\");\n        var rulerLine = DOMUtils.appendOrSelect(ruler, \"line.ruler-line\");\n        var dataPointElements = svg.selectAll(\"[role=graphics-symbol]\");\n        var displayData = this.model.getDisplayData();\n        var rangeScale = this.services.cartesianScales.getRangeScale();\n        var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];\n        var pointsWithinLine = displayData\n            .map(function (d) { return ({\n            domainValue: _this.services.cartesianScales.getDomainValue(d),\n            originalData: d\n        }); })\n            .filter(function (d) {\n            return pointIsWithinThreshold(d.domainValue, mouseCoordinate);\n        });\n        if (this.pointsWithinLine &&\n            pointsWithinLine.length === this.pointsWithinLine.length &&\n            pointsWithinLine.map(function (point) { return point.domainValue; }).join() ===\n                this.pointsWithinLine.map(function (point) { return point.domainValue; }).join()) {\n            this.pointsWithinLine = pointsWithinLine;\n            return this.services.events.dispatchEvent(Events.Tooltip.MOVE, {\n                mousePosition: [x, y]\n            });\n        }\n        this.pointsWithinLine = pointsWithinLine;\n        /**\n         * Find matches, reduce is used instead of filter\n         * to only get elements which belong to the same axis coordinate\n         */\n        var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function (accum, currentValue) {\n            if (accum.length === 0) {\n                accum.push(currentValue);\n                return accum;\n            }\n            // store the first element of the accumulator array to compare it with current element being processed\n            var sampleAccumValue = accum[0].domainValue;\n            var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);\n            var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);\n            if (distanceToCurrentValue > distanceToAccumValue) {\n                // if distance with current value is bigger than already existing value in the accumulator, skip current iteration\n                return accum;\n            }\n            else if (distanceToCurrentValue < distanceToAccumValue) {\n                // currentValue data point is closer to mouse inside the threshold area, so reinstantiate array\n                accum = [currentValue];\n            }\n            else {\n                // currentValue is equal to already stored values, which means there's another match on the same coordinate\n                accum.push(currentValue);\n            }\n            return accum;\n        }, []);\n        // some data point match\n        if (dataPointsMatchingRulerLine.length > 0) {\n            var rangeIdentifier_1 = this.services.cartesianScales.getRangeIdentifier();\n            var tooltipData = dataPointsMatchingRulerLine\n                .map(function (d) { return d.originalData; })\n                .filter(function (d) {\n                var value = d[rangeIdentifier_1];\n                return value !== null && value !== undefined;\n            });\n            // get elements on which we should trigger mouse events\n            var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function (d) { return d.domainValue; });\n            var elementsToHighlight = dataPointElements.filter(function (d) {\n                var domainValue = _this.services.cartesianScales.getDomainValue(d);\n                return domainValuesMatchingRulerLine_1.includes(domainValue);\n            });\n            /** if we pass from a trigger area to another one\n             * mouseout on previous elements won't get dispatched\n             * so we need to do it manually\n             */\n            if (this.elementsToHighlight &&\n                this.elementsToHighlight.size() > 0 &&\n                !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {\n                this.hideRuler();\n            }\n            elementsToHighlight.dispatch(\"mouseover\");\n            // set current hovered elements\n            this.elementsToHighlight = elementsToHighlight;\n            this.services.events.dispatchEvent(Events.Tooltip.SHOW, {\n                mousePosition: [x, y],\n                hoveredElement: rulerLine,\n                data: this.formatTooltipData(tooltipData)\n            });\n            ruler.attr(\"opacity\", 1);\n            // line snaps to matching point\n            var sampleMatch = dataPointsMatchingRulerLine[0];\n            if (orientation === \"horizontal\") {\n                rulerLine\n                    .attr(\"x1\", yScaleStart)\n                    .attr(\"x2\", yScaleEnd)\n                    .attr(\"y1\", sampleMatch.domainValue)\n                    .attr(\"y2\", sampleMatch.domainValue);\n            }\n            else {\n                rulerLine\n                    .attr(\"y1\", yScaleStart)\n                    .attr(\"y2\", yScaleEnd)\n                    .attr(\"x1\", sampleMatch.domainValue)\n                    .attr(\"x2\", sampleMatch.domainValue);\n            }\n        }\n        else {\n            this.hideRuler();\n        }\n    };\n    Ruler.prototype.hideRuler = function () {\n        var svg = this.parent;\n        var ruler = DOMUtils.appendOrSelect(svg, \"g.ruler\");\n        var dataPointElements = svg.selectAll(\"[role=graphics-symbol]\");\n        dataPointElements.dispatch(\"mouseout\");\n        this.services.events.dispatchEvent(Events.Tooltip.HIDE);\n        ruler.attr(\"opacity\", 0);\n    };\n    /**\n     * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.\n     */\n    Ruler.prototype.addBackdropEventListeners = function () {\n        var self = this;\n        var displayData = this.model.getDisplayData();\n        var mouseMoveCallback = function () {\n            var pos = mouse(self.parent.node());\n            self.showRuler(pos);\n        };\n        // Debounce mouseMoveCallback if there are more than 100 datapoints\n        if (displayData.length > 100) {\n            var debounceThreshold = (displayData.length % 50) * 12.5;\n            mouseMoveCallback = Tools.debounceWithD3MousePosition(function () {\n                var mousePosition = this.mousePosition;\n                self.showRuler(mousePosition);\n            }, debounceThreshold, this.parent.node());\n        }\n        this.backdrop\n            .on(\"mousemove mouseover\", mouseMoveCallback)\n            .on(\"mouseout\", this.hideRuler.bind(this));\n    };\n    Ruler.prototype.drawBackdrop = function () {\n        var svg = this.parent;\n        var mainXScale = this.services.cartesianScales.getMainXScale();\n        var mainYScale = this.services.cartesianScales.getMainYScale();\n        var _a = mainXScale.range(), xScaleStart = _a[0], xScaleEnd = _a[1];\n        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];\n        // Get height from the grid\n        this.backdrop = DOMUtils.appendOrSelect(svg, \"svg.chart-grid-backdrop\");\n        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, \"rect.chart-grid-backdrop\");\n        this.backdrop\n            .merge(backdropRect)\n            .attr(\"x\", xScaleStart)\n            .attr(\"y\", yScaleStart)\n            .attr(\"width\", xScaleEnd - xScaleStart)\n            .attr(\"height\", yScaleEnd - yScaleStart)\n            .lower();\n        backdropRect.attr(\"width\", \"100%\").attr(\"height\", \"100%\");\n    };\n    return Ruler;\n}(Component));\nexport { Ruler };\n//# sourceMappingURL=../../../src/components/axes/ruler.js.map"]},"metadata":{},"sourceType":"module"}