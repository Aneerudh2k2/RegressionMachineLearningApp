{"ast":null,"code":"// Internal Imports\nimport * as Configuration from \"./configuration\";\nimport { Tools } from \"./tools\";\nimport * as colorPalettes from \"./services/colorPalettes\";\nimport { Events, ScaleTypes } from \"./interfaces\"; // D3\n\nimport { scaleOrdinal } from \"d3-scale\";\nimport { map } from \"d3-collection\";\nimport { stack } from \"d3-shape\";\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\n\nvar ChartModel =\n/** @class */\nfunction () {\n  function ChartModel(services) {\n    // Internal Model state\n    this.state = {\n      options: {}\n    }; // Fill scales & fill related objects\n\n    this.colorScale = {};\n    this.services = services;\n  }\n\n  ChartModel.prototype.getAllDataFromDomain = function () {\n    if (!this.get(\"data\")) {\n      return null;\n    }\n\n    var dataGroups = this.getDataGroups(); // Remove datasets that have been disabled\n\n    var displayData = Tools.clone(this.get(\"data\"));\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    var axesOptions = this.getOptions().axes; // Check for custom domain\n\n    if (axesOptions) {\n      Object.keys(axesOptions).forEach(function (axis) {\n        if (axesOptions[axis].mapsTo && axesOptions[axis].domain) {\n          var mapsTo_1 = axesOptions[axis].mapsTo;\n\n          if (axesOptions[axis].scaleType === ScaleTypes.LABELS) {\n            displayData = displayData.filter(function (datum) {\n              return axesOptions[axis].domain.includes(datum[mapsTo_1]);\n            });\n          } else {\n            var _a = axesOptions[axis].domain,\n                start_1 = _a[0],\n                end_1 = _a[1]; // Filter out data outside domain\n\n            displayData = displayData.filter(function (datum) {\n              return datum[mapsTo_1] >= start_1 && datum[mapsTo_1] <= end_1;\n            });\n          }\n        }\n      });\n    }\n\n    return displayData.filter(function (datum) {\n      return dataGroups.find(function (group) {\n        return group.name === datum[groupMapsTo];\n      });\n    });\n  };\n\n  ChartModel.prototype.getDisplayData = function () {\n    if (!this.get(\"data\")) {\n      return null;\n    }\n\n    var ACTIVE = Configuration.legend.items.status.ACTIVE;\n    var dataGroups = this.getDataGroups();\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    var allDataFromDomain = this.getAllDataFromDomain();\n    return allDataFromDomain.filter(function (datum) {\n      var group = dataGroups.find(function (group) {\n        return group.name === datum[groupMapsTo];\n      });\n      return group.status === ACTIVE;\n    });\n  };\n\n  ChartModel.prototype.getData = function () {\n    return this.get(\"data\");\n  };\n\n  ChartModel.prototype.isDataEmpty = function () {\n    return !this.getData().length;\n  };\n  /**\n   *\n   * @param newData The new raw data to be set\n   */\n\n\n  ChartModel.prototype.setData = function (newData) {\n    var sanitizedData = this.sanitize(Tools.clone(newData));\n    var dataGroups = this.generateDataGroups(sanitizedData);\n    this.set({\n      data: sanitizedData,\n      dataGroups: dataGroups\n    });\n    return sanitizedData;\n  };\n\n  ChartModel.prototype.getDataGroups = function () {\n    return this.get(\"dataGroups\");\n  };\n\n  ChartModel.prototype.getActiveDataGroups = function () {\n    var ACTIVE = Configuration.legend.items.status.ACTIVE;\n    return this.getDataGroups().filter(function (dataGroup) {\n      return dataGroup.status === ACTIVE;\n    });\n  };\n\n  ChartModel.prototype.getDataGroupNames = function () {\n    return this.getDataGroups().map(function (dataGroup) {\n      return dataGroup.name;\n    });\n  };\n\n  ChartModel.prototype.getActiveDataGroupNames = function () {\n    return this.getActiveDataGroups().map(function (dataGroup) {\n      return dataGroup.name;\n    });\n  };\n\n  ChartModel.prototype.getGroupedData = function () {\n    var displayData = this.getDisplayData();\n    var groupedData = {};\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    displayData.map(function (datum) {\n      var group = datum[groupMapsTo];\n\n      if (groupedData[group] !== null && groupedData[group] !== undefined) {\n        groupedData[group].push(datum);\n      } else {\n        groupedData[group] = [datum];\n      }\n    });\n    return Object.keys(groupedData).map(function (groupName) {\n      return {\n        name: groupName,\n        data: groupedData[groupName]\n      };\n    });\n  };\n\n  ChartModel.prototype.getDataValuesGroupedByKeys = function () {\n    var options = this.getOptions();\n    var groupMapsTo = options.data.groupMapsTo;\n    var displayData = this.getDisplayData();\n    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();\n    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();\n    var stackKeys = map(displayData, function (datum) {\n      return datum[domainIdentifier];\n    }).keys();\n    var axisPosition = this.services.cartesianScales.domainAxisPosition;\n    var scaleType = options.axes[axisPosition].scaleType; // Sort keys\n\n    if (scaleType === ScaleTypes.TIME) {\n      stackKeys.sort(function (a, b) {\n        var dateA = new Date(a);\n        var dateB = new Date(b);\n        return dateA - dateB;\n      });\n    } else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {\n      stackKeys.sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    var dataGroupNames = this.getDataGroupNames();\n    return stackKeys.map(function (key) {\n      var correspondingValues = {\n        sharedStackKey: key\n      };\n      dataGroupNames.forEach(function (dataGroupName) {\n        var correspondingDatum = displayData.find(function (datum) {\n          return datum[groupMapsTo] === dataGroupName && datum[domainIdentifier].toString() === key;\n        });\n        correspondingValues[dataGroupName] = correspondingDatum ? correspondingDatum[rangeIdentifier] : null;\n      });\n      return correspondingValues;\n    });\n  };\n\n  ChartModel.prototype.getStackedData = function (_a) {\n    var percentage = (_a === void 0 ? {\n      percentage: false\n    } : _a).percentage;\n    var options = this.getOptions();\n    var groupMapsTo = options.data.groupMapsTo;\n    var dataGroupNames = this.getDataGroupNames();\n    var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys();\n\n    if (percentage) {\n      var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function (d) {\n        return [d.sharedStackKey, 0];\n      }));\n      dataValuesGroupedByKeys.forEach(function (d) {\n        dataGroupNames.forEach(function (name) {\n          maxByKey_1[d.sharedStackKey] += d[name];\n        });\n      }); // cycle through data values to get percentage\n\n      dataValuesGroupedByKeys.forEach(function (d) {\n        dataGroupNames.forEach(function (name) {\n          d[name] = d[name] / maxByKey_1[d.sharedStackKey] * 100;\n        });\n      });\n    }\n\n    return stack().keys(dataGroupNames)(dataValuesGroupedByKeys).map(function (series, i) {\n      // Add data group names to each series\n      return Object.keys(series).filter(function (key) {\n        return !isNaN(key);\n      }).map(function (key) {\n        var element = series[key];\n        element[groupMapsTo] = dataGroupNames[i];\n        return element;\n      });\n    });\n  };\n  /**\n   * @return {Object} The chart's options\n   */\n\n\n  ChartModel.prototype.getOptions = function () {\n    return this.state.options;\n  };\n\n  ChartModel.prototype.set = function (newState, skipUpdate) {\n    if (skipUpdate === void 0) {\n      skipUpdate = false;\n    }\n\n    this.state = Object.assign({}, this.state, newState);\n\n    if (!skipUpdate) {\n      this.update();\n    }\n  };\n\n  ChartModel.prototype.get = function (property) {\n    if (property) {\n      return this.state[property];\n    } else {\n      return this.state;\n    }\n  };\n  /**\n   *\n   * @param newOptions New options to be set\n   */\n\n\n  ChartModel.prototype.setOptions = function (newOptions) {\n    this.set({\n      options: Tools.merge(this.getOptions(), newOptions)\n    });\n  };\n  /**\n   *\n   * Updates miscellanous information within the model\n   * such as the color scales, or the legend data labels\n   */\n\n\n  ChartModel.prototype.update = function () {\n    if (!this.getDisplayData()) {\n      return;\n    }\n\n    this.updateAllDataGroups();\n    this.setColorScale();\n    this.services.events.dispatchEvent(Events.Model.UPDATE);\n  };\n\n  ChartModel.prototype.setUpdateCallback = function (cb) {\n    this.updateCallback = cb;\n  };\n  /*\n   * Data labels\n   */\n\n\n  ChartModel.prototype.toggleDataLabel = function (changedLabel) {\n    var _a = Configuration.legend.items.status,\n        ACTIVE = _a.ACTIVE,\n        DISABLED = _a.DISABLED;\n    var dataGroups = this.getDataGroups();\n    var hasDeactivatedItems = dataGroups.some(function (group) {\n      return group.status === DISABLED;\n    });\n    var activeItems = dataGroups.filter(function (group) {\n      return group.status === ACTIVE;\n    }); // If there are deactivated items, toggle \"changedLabel\"\n\n    if (hasDeactivatedItems) {\n      // If the only active item is being toggled\n      // Activate all items\n      if (activeItems.length === 1 && activeItems[0].name === changedLabel) {\n        // If every item is active, then enable \"changedLabel\" and disable all other items\n        dataGroups.forEach(function (group, i) {\n          dataGroups[i].status = ACTIVE;\n        });\n      } else {\n        var indexToChange = dataGroups.findIndex(function (group) {\n          return group.name === changedLabel;\n        });\n        dataGroups[indexToChange].status = dataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED;\n      }\n    } else {\n      // If every item is active, then enable \"changedLabel\" and disable all other items\n      dataGroups.forEach(function (group, i) {\n        dataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED;\n      });\n    } // Updates selected groups\n\n\n    var updatedActiveItems = dataGroups.filter(function (group) {\n      return group.status === ACTIVE;\n    });\n    var options = this.getOptions();\n    var hasUpdatedDeactivatedItems = dataGroups.some(function (group) {\n      return group.status === DISABLED;\n    }); // If there are deactivated items, map the item name into selected groups\n\n    if (hasUpdatedDeactivatedItems) {\n      options.data.selectedGroups = updatedActiveItems.map(function (activeItem) {\n        return activeItem.name;\n      });\n    } else {\n      // If every item is active, clear array\n      options.data.selectedGroups = [];\n    } // dispatch legend filtering event with the status of all the dataLabels\n\n\n    this.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n      dataGroups: dataGroups\n    }); // Update model\n\n    this.set({\n      dataGroups: dataGroups\n    });\n  };\n  /**\n   * Should the data point be filled?\n   * @param group\n   * @param key\n   * @param value\n   * @param defaultFilled the default for this chart\n   */\n\n\n  ChartModel.prototype.getIsFilled = function (group, key, data, defaultFilled) {\n    var options = this.getOptions();\n\n    if (options.getIsFilled) {\n      return options.getIsFilled(group, key, data, defaultFilled);\n    } else {\n      return defaultFilled;\n    }\n  };\n\n  ChartModel.prototype.getFillColor = function (group, key, data) {\n    var options = this.getOptions();\n    var defaultFillColor = this.getFillScale()(group);\n\n    if (options.getFillColor) {\n      return options.getFillColor(group, key, data, defaultFillColor);\n    } else {\n      return defaultFillColor;\n    }\n  };\n\n  ChartModel.prototype.getStrokeColor = function (group, key, data) {\n    var options = this.getOptions();\n    var defaultStrokeColor = this.colorScale(group);\n\n    if (options.getStrokeColor) {\n      return options.getStrokeColor(group, key, data, defaultStrokeColor);\n    } else {\n      return defaultStrokeColor;\n    }\n  };\n\n  ChartModel.prototype.getFillScale = function () {\n    return this.colorScale;\n  };\n  /**\n   * For charts that might hold an associated status for their dataset\n   */\n\n\n  ChartModel.prototype.getStatus = function () {\n    return null;\n  };\n  /**\n   * Converts data provided in the older format to tabular\n   *\n   */\n\n\n  ChartModel.prototype.transformToTabularData = function (data) {\n    console.warn(\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/tutorials--tabular-data-format\");\n    var tabularData = [];\n    var datasets = data.datasets,\n        labels = data.labels; // Loop through all datasets\n\n    datasets.forEach(function (dataset) {\n      // Update each data point to the new format\n      dataset.data.forEach(function (datum, i) {\n        var group;\n        var datasetLabel = Tools.getProperty(dataset, \"label\");\n\n        if (datasetLabel === null) {\n          var correspondingLabel = Tools.getProperty(labels, i);\n\n          if (correspondingLabel) {\n            group = correspondingLabel;\n          } else {\n            group = \"Ungrouped\";\n          }\n        } else {\n          group = datasetLabel;\n        }\n\n        var updatedDatum = {\n          group: group,\n          key: labels[i]\n        };\n\n        if (isNaN(datum)) {\n          updatedDatum[\"value\"] = datum.value;\n          updatedDatum[\"date\"] = datum.date;\n        } else {\n          updatedDatum[\"value\"] = datum;\n        }\n\n        tabularData.push(updatedDatum);\n      });\n    });\n    return tabularData;\n  };\n\n  ChartModel.prototype.getTabularData = function (data) {\n    // if data is not an array\n    if (!Array.isArray(data)) {\n      return this.transformToTabularData(data);\n    }\n\n    return data;\n  };\n\n  ChartModel.prototype.sanitize = function (data) {\n    return this.getTabularData(data);\n  };\n  /*\n   * Data groups\n   */\n\n\n  ChartModel.prototype.updateAllDataGroups = function () {\n    // allDataGroups is used to generate a color scale that applies\n    // to all the groups. Now when the data updates, you might remove a group,\n    // and then bring it back in a newer data update, therefore\n    // the order of the groups in allDataGroups matters so that you'd never\n    // have an incorrect color assigned to a group.\n    var _this = this; // Also, a new group should only be added to allDataGroups if\n    // it doesn't currently exist\n\n\n    if (!this.allDataGroups) {\n      this.allDataGroups = this.getDataGroupNames();\n    } else {\n      // Loop through current data groups\n      this.getDataGroupNames().forEach(function (dataGroupName) {\n        // If group name hasn't been stored yet, store it\n        if (_this.allDataGroups.indexOf(dataGroupName) === -1) {\n          _this.allDataGroups.push(dataGroupName);\n        }\n      });\n    }\n  };\n\n  ChartModel.prototype.generateDataGroups = function (data) {\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    var _a = Configuration.legend.items.status,\n        ACTIVE = _a.ACTIVE,\n        DISABLED = _a.DISABLED;\n    var options = this.getOptions();\n    var uniqueDataGroups = map(data, function (datum) {\n      return datum[groupMapsTo];\n    }).keys(); // check if selectedGroups can be applied to chart with current data groups\n\n    if (options.data.selectedGroups.length) {\n      var hasAllSelectedGroups = options.data.selectedGroups.every(function (groupName) {\n        return uniqueDataGroups.includes(groupName);\n      });\n\n      if (!hasAllSelectedGroups) {\n        options.data.selectedGroups = [];\n      }\n    } // Get group status based on items in selected groups\n\n\n    var getStatus = function (groupName) {\n      return !options.data.selectedGroups.length || options.data.selectedGroups.includes(groupName) ? ACTIVE : DISABLED;\n    };\n\n    return uniqueDataGroups.map(function (groupName) {\n      return {\n        name: groupName,\n        status: getStatus(groupName)\n      };\n    });\n  };\n  /*\n   * Fill scales\n   */\n\n\n  ChartModel.prototype.setColorScale = function () {\n    var defaultColors = colorPalettes.DEFAULT;\n    var options = this.getOptions();\n    var userProvidedScale = Tools.getProperty(options, \"color\", \"scale\"); // If there is no valid user provided scale, use the default set of colors\n\n    if (userProvidedScale === null || Object.keys(userProvidedScale).length === 0) {\n      this.colorScale = scaleOrdinal().range(defaultColors).domain(this.allDataGroups);\n      return;\n    }\n    /**\n     * Go through allDataGroups. If a data group has a color value provided\n     * by the user, add that to the color range\n     * If not, add a default color\n     */\n\n\n    var colorRange = [];\n    var colorIndex = 0;\n    this.allDataGroups.forEach(function (dataGroup) {\n      if (userProvidedScale[dataGroup]) {\n        colorRange.push(userProvidedScale[dataGroup]);\n      } else {\n        colorRange.push(defaultColors[colorIndex]);\n      }\n\n      if (colorIndex === defaultColors.length - 1) {\n        colorIndex = 0;\n      } else {\n        colorIndex++;\n      }\n    });\n    this.colorScale = scaleOrdinal().range(colorRange).domain(this.allDataGroups);\n  };\n\n  return ChartModel;\n}();\n\nexport { ChartModel };","map":{"version":3,"sources":["/Users/nicholasrenotte/Desktop/Regression/app/client/node_modules/@carbon/charts/model.js"],"names":["Configuration","Tools","colorPalettes","Events","ScaleTypes","scaleOrdinal","map","stack","ChartModel","services","state","options","colorScale","prototype","getAllDataFromDomain","get","dataGroups","getDataGroups","displayData","clone","groupMapsTo","getOptions","data","axesOptions","axes","Object","keys","forEach","axis","mapsTo","domain","mapsTo_1","scaleType","LABELS","filter","datum","includes","_a","start_1","end_1","find","group","name","getDisplayData","ACTIVE","legend","items","status","allDataFromDomain","getData","isDataEmpty","length","setData","newData","sanitizedData","sanitize","generateDataGroups","set","getActiveDataGroups","dataGroup","getDataGroupNames","getActiveDataGroupNames","getGroupedData","groupedData","undefined","push","groupName","getDataValuesGroupedByKeys","domainIdentifier","cartesianScales","getDomainIdentifier","rangeIdentifier","getRangeIdentifier","stackKeys","axisPosition","domainAxisPosition","TIME","sort","a","b","dateA","Date","dateB","LOG","LINEAR","dataGroupNames","key","correspondingValues","sharedStackKey","dataGroupName","correspondingDatum","toString","getStackedData","percentage","dataValuesGroupedByKeys","maxByKey_1","fromPairs","d","series","i","isNaN","element","newState","skipUpdate","assign","update","property","setOptions","newOptions","merge","updateAllDataGroups","setColorScale","events","dispatchEvent","Model","UPDATE","setUpdateCallback","cb","updateCallback","toggleDataLabel","changedLabel","DISABLED","hasDeactivatedItems","some","activeItems","indexToChange","findIndex","updatedActiveItems","hasUpdatedDeactivatedItems","selectedGroups","activeItem","Legend","ITEMS_UPDATE","getIsFilled","defaultFilled","getFillColor","defaultFillColor","getFillScale","getStrokeColor","defaultStrokeColor","getStatus","transformToTabularData","console","warn","tabularData","datasets","labels","dataset","datasetLabel","getProperty","correspondingLabel","updatedDatum","value","date","getTabularData","Array","isArray","_this","allDataGroups","indexOf","uniqueDataGroups","hasAllSelectedGroups","every","defaultColors","DEFAULT","userProvidedScale","range","colorRange","colorIndex"],"mappings":"AAAA;AACA,OAAO,KAAKA,aAAZ,MAA+B,iBAA/B;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,OAAO,KAAKC,aAAZ,MAA+B,0BAA/B;AACA,SAASC,MAAT,EAAiBC,UAAjB,QAAmC,cAAnC,C,CACA;;AACA,SAASC,YAAT,QAA6B,UAA7B;AACA,SAASC,GAAT,QAAoB,eAApB;AACA,SAASC,KAAT,QAAsB,UAAtB;AACA;;;AAEA,IAAIC,UAAU;AAAG;AAAe,YAAY;AACxC,WAASA,UAAT,CAAoBC,QAApB,EAA8B;AAC1B;AACA,SAAKC,KAAL,GAAa;AACTC,MAAAA,OAAO,EAAE;AADA,KAAb,CAF0B,CAK1B;;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKH,QAAL,GAAgBA,QAAhB;AACH;;AACDD,EAAAA,UAAU,CAACK,SAAX,CAAqBC,oBAArB,GAA4C,YAAY;AACpD,QAAI,CAAC,KAAKC,GAAL,CAAS,MAAT,CAAL,EAAuB;AACnB,aAAO,IAAP;AACH;;AACD,QAAIC,UAAU,GAAG,KAAKC,aAAL,EAAjB,CAJoD,CAKpD;;AACA,QAAIC,WAAW,GAAGjB,KAAK,CAACkB,KAAN,CAAY,KAAKJ,GAAL,CAAS,MAAT,CAAZ,CAAlB;AACA,QAAIK,WAAW,GAAG,KAAKC,UAAL,GAAkBC,IAAlB,CAAuBF,WAAzC;AACA,QAAIG,WAAW,GAAG,KAAKF,UAAL,GAAkBG,IAApC,CARoD,CASpD;;AACA,QAAID,WAAJ,EAAiB;AACbE,MAAAA,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBI,OAAzB,CAAiC,UAAUC,IAAV,EAAgB;AAC7C,YAAIL,WAAW,CAACK,IAAD,CAAX,CAAkBC,MAAlB,IAA4BN,WAAW,CAACK,IAAD,CAAX,CAAkBE,MAAlD,EAA0D;AACtD,cAAIC,QAAQ,GAAGR,WAAW,CAACK,IAAD,CAAX,CAAkBC,MAAjC;;AACA,cAAIN,WAAW,CAACK,IAAD,CAAX,CAAkBI,SAAlB,KAAgC5B,UAAU,CAAC6B,MAA/C,EAAuD;AACnDf,YAAAA,WAAW,GAAGA,WAAW,CAACgB,MAAZ,CAAmB,UAAUC,KAAV,EAAiB;AAC9C,qBAAOZ,WAAW,CAACK,IAAD,CAAX,CAAkBE,MAAlB,CAAyBM,QAAzB,CAAkCD,KAAK,CAACJ,QAAD,CAAvC,CAAP;AACH,aAFa,CAAd;AAGH,WAJD,MAKK;AACD,gBAAIM,EAAE,GAAGd,WAAW,CAACK,IAAD,CAAX,CAAkBE,MAA3B;AAAA,gBAAmCQ,OAAO,GAAGD,EAAE,CAAC,CAAD,CAA/C;AAAA,gBAAoDE,KAAK,GAAGF,EAAE,CAAC,CAAD,CAA9D,CADC,CAED;;AACAnB,YAAAA,WAAW,GAAGA,WAAW,CAACgB,MAAZ,CAAmB,UAAUC,KAAV,EAAiB;AAC9C,qBAAOA,KAAK,CAACJ,QAAD,CAAL,IAAmBO,OAAnB,IAA8BH,KAAK,CAACJ,QAAD,CAAL,IAAmBQ,KAAxD;AACH,aAFa,CAAd;AAGH;AACJ;AACJ,OAhBD;AAiBH;;AACD,WAAOrB,WAAW,CAACgB,MAAZ,CAAmB,UAAUC,KAAV,EAAiB;AACvC,aAAOnB,UAAU,CAACwB,IAAX,CAAgB,UAAUC,KAAV,EAAiB;AAAE,eAAOA,KAAK,CAACC,IAAN,KAAeP,KAAK,CAACf,WAAD,CAA3B;AAA2C,OAA9E,CAAP;AACH,KAFM,CAAP;AAGH,GAhCD;;AAiCAZ,EAAAA,UAAU,CAACK,SAAX,CAAqB8B,cAArB,GAAsC,YAAY;AAC9C,QAAI,CAAC,KAAK5B,GAAL,CAAS,MAAT,CAAL,EAAuB;AACnB,aAAO,IAAP;AACH;;AACD,QAAI6B,MAAM,GAAG5C,aAAa,CAAC6C,MAAd,CAAqBC,KAArB,CAA2BC,MAA3B,CAAkCH,MAA/C;AACA,QAAI5B,UAAU,GAAG,KAAKC,aAAL,EAAjB;AACA,QAAIG,WAAW,GAAG,KAAKC,UAAL,GAAkBC,IAAlB,CAAuBF,WAAzC;AACA,QAAI4B,iBAAiB,GAAG,KAAKlC,oBAAL,EAAxB;AACA,WAAOkC,iBAAiB,CAACd,MAAlB,CAAyB,UAAUC,KAAV,EAAiB;AAC7C,UAAIM,KAAK,GAAGzB,UAAU,CAACwB,IAAX,CAAgB,UAAUC,KAAV,EAAiB;AAAE,eAAOA,KAAK,CAACC,IAAN,KAAeP,KAAK,CAACf,WAAD,CAA3B;AAA2C,OAA9E,CAAZ;AACA,aAAOqB,KAAK,CAACM,MAAN,KAAiBH,MAAxB;AACH,KAHM,CAAP;AAIH,GAZD;;AAaApC,EAAAA,UAAU,CAACK,SAAX,CAAqBoC,OAArB,GAA+B,YAAY;AACvC,WAAO,KAAKlC,GAAL,CAAS,MAAT,CAAP;AACH,GAFD;;AAGAP,EAAAA,UAAU,CAACK,SAAX,CAAqBqC,WAArB,GAAmC,YAAY;AAC3C,WAAO,CAAC,KAAKD,OAAL,GAAeE,MAAvB;AACH,GAFD;AAGA;;;;;;AAIA3C,EAAAA,UAAU,CAACK,SAAX,CAAqBuC,OAArB,GAA+B,UAAUC,OAAV,EAAmB;AAC9C,QAAIC,aAAa,GAAG,KAAKC,QAAL,CAActD,KAAK,CAACkB,KAAN,CAAYkC,OAAZ,CAAd,CAApB;AACA,QAAIrC,UAAU,GAAG,KAAKwC,kBAAL,CAAwBF,aAAxB,CAAjB;AACA,SAAKG,GAAL,CAAS;AACLnC,MAAAA,IAAI,EAAEgC,aADD;AAELtC,MAAAA,UAAU,EAAEA;AAFP,KAAT;AAIA,WAAOsC,aAAP;AACH,GARD;;AASA9C,EAAAA,UAAU,CAACK,SAAX,CAAqBI,aAArB,GAAqC,YAAY;AAC7C,WAAO,KAAKF,GAAL,CAAS,YAAT,CAAP;AACH,GAFD;;AAGAP,EAAAA,UAAU,CAACK,SAAX,CAAqB6C,mBAArB,GAA2C,YAAY;AACnD,QAAId,MAAM,GAAG5C,aAAa,CAAC6C,MAAd,CAAqBC,KAArB,CAA2BC,MAA3B,CAAkCH,MAA/C;AACA,WAAO,KAAK3B,aAAL,GAAqBiB,MAArB,CAA4B,UAAUyB,SAAV,EAAqB;AAAE,aAAOA,SAAS,CAACZ,MAAV,KAAqBH,MAA5B;AAAqC,KAAxF,CAAP;AACH,GAHD;;AAIApC,EAAAA,UAAU,CAACK,SAAX,CAAqB+C,iBAArB,GAAyC,YAAY;AACjD,WAAO,KAAK3C,aAAL,GAAqBX,GAArB,CAAyB,UAAUqD,SAAV,EAAqB;AAAE,aAAOA,SAAS,CAACjB,IAAjB;AAAwB,KAAxE,CAAP;AACH,GAFD;;AAGAlC,EAAAA,UAAU,CAACK,SAAX,CAAqBgD,uBAArB,GAA+C,YAAY;AACvD,WAAO,KAAKH,mBAAL,GAA2BpD,GAA3B,CAA+B,UAAUqD,SAAV,EAAqB;AAAE,aAAOA,SAAS,CAACjB,IAAjB;AAAwB,KAA9E,CAAP;AACH,GAFD;;AAGAlC,EAAAA,UAAU,CAACK,SAAX,CAAqBiD,cAArB,GAAsC,YAAY;AAC9C,QAAI5C,WAAW,GAAG,KAAKyB,cAAL,EAAlB;AACA,QAAIoB,WAAW,GAAG,EAAlB;AACA,QAAI3C,WAAW,GAAG,KAAKC,UAAL,GAAkBC,IAAlB,CAAuBF,WAAzC;AACAF,IAAAA,WAAW,CAACZ,GAAZ,CAAgB,UAAU6B,KAAV,EAAiB;AAC7B,UAAIM,KAAK,GAAGN,KAAK,CAACf,WAAD,CAAjB;;AACA,UAAI2C,WAAW,CAACtB,KAAD,CAAX,KAAuB,IAAvB,IACAsB,WAAW,CAACtB,KAAD,CAAX,KAAuBuB,SAD3B,EACsC;AAClCD,QAAAA,WAAW,CAACtB,KAAD,CAAX,CAAmBwB,IAAnB,CAAwB9B,KAAxB;AACH,OAHD,MAIK;AACD4B,QAAAA,WAAW,CAACtB,KAAD,CAAX,GAAqB,CAACN,KAAD,CAArB;AACH;AACJ,KATD;AAUA,WAAOV,MAAM,CAACC,IAAP,CAAYqC,WAAZ,EAAyBzD,GAAzB,CAA6B,UAAU4D,SAAV,EAAqB;AAAE,aAAQ;AAC/DxB,QAAAA,IAAI,EAAEwB,SADyD;AAE/D5C,QAAAA,IAAI,EAAEyC,WAAW,CAACG,SAAD;AAF8C,OAAR;AAGtD,KAHE,CAAP;AAIH,GAlBD;;AAmBA1D,EAAAA,UAAU,CAACK,SAAX,CAAqBsD,0BAArB,GAAkD,YAAY;AAC1D,QAAIxD,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAID,WAAW,GAAGT,OAAO,CAACW,IAAR,CAAaF,WAA/B;AACA,QAAIF,WAAW,GAAG,KAAKyB,cAAL,EAAlB;AACA,QAAIyB,gBAAgB,GAAG,KAAK3D,QAAL,CAAc4D,eAAd,CAA8BC,mBAA9B,EAAvB;AACA,QAAIC,eAAe,GAAG,KAAK9D,QAAL,CAAc4D,eAAd,CAA8BG,kBAA9B,EAAtB;AACA,QAAIC,SAAS,GAAGnE,GAAG,CAACY,WAAD,EAAc,UAAUiB,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACiC,gBAAD,CAAZ;AAAiC,KAAlE,CAAH,CAAuE1C,IAAvE,EAAhB;AACA,QAAIgD,YAAY,GAAG,KAAKjE,QAAL,CAAc4D,eAAd,CAA8BM,kBAAjD;AACA,QAAI3C,SAAS,GAAGrB,OAAO,CAACa,IAAR,CAAakD,YAAb,EAA2B1C,SAA3C,CAR0D,CAS1D;;AACA,QAAIA,SAAS,KAAK5B,UAAU,CAACwE,IAA7B,EAAmC;AAC/BH,MAAAA,SAAS,CAACI,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC3B,YAAIC,KAAK,GAAG,IAAIC,IAAJ,CAASH,CAAT,CAAZ;AACA,YAAII,KAAK,GAAG,IAAID,IAAJ,CAASF,CAAT,CAAZ;AACA,eAAOC,KAAK,GAAGE,KAAf;AACH,OAJD;AAKH,KAND,MAOK,IAAIlD,SAAS,KAAK5B,UAAU,CAAC+E,GAAzB,IACLnD,SAAS,KAAK5B,UAAU,CAACgF,MADxB,EACgC;AACjCX,MAAAA,SAAS,CAACI,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAAE,eAAOD,CAAC,GAAGC,CAAX;AAAe,OAAhD;AACH;;AACD,QAAIM,cAAc,GAAG,KAAKzB,iBAAL,EAArB;AACA,WAAOa,SAAS,CAACnE,GAAV,CAAc,UAAUgF,GAAV,EAAe;AAChC,UAAIC,mBAAmB,GAAG;AAAEC,QAAAA,cAAc,EAAEF;AAAlB,OAA1B;AACAD,MAAAA,cAAc,CAAC1D,OAAf,CAAuB,UAAU8D,aAAV,EAAyB;AAC5C,YAAIC,kBAAkB,GAAGxE,WAAW,CAACsB,IAAZ,CAAiB,UAAUL,KAAV,EAAiB;AACvD,iBAAQA,KAAK,CAACf,WAAD,CAAL,KAAuBqE,aAAvB,IACJtD,KAAK,CAACiC,gBAAD,CAAL,CAAwBuB,QAAxB,OAAuCL,GAD3C;AAEH,SAHwB,CAAzB;AAIAC,QAAAA,mBAAmB,CAACE,aAAD,CAAnB,GAAqCC,kBAAkB,GACjDA,kBAAkB,CAACnB,eAAD,CAD+B,GAEjD,IAFN;AAGH,OARD;AASA,aAAOgB,mBAAP;AACH,KAZM,CAAP;AAaH,GAnCD;;AAoCA/E,EAAAA,UAAU,CAACK,SAAX,CAAqB+E,cAArB,GAAsC,UAAUvD,EAAV,EAAc;AAChD,QAAIwD,UAAU,GAAG,CAACxD,EAAE,KAAK,KAAK,CAAZ,GAAgB;AAAEwD,MAAAA,UAAU,EAAE;AAAd,KAAhB,GAAwCxD,EAAzC,EAA6CwD,UAA9D;AACA,QAAIlF,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAID,WAAW,GAAGT,OAAO,CAACW,IAAR,CAAaF,WAA/B;AACA,QAAIiE,cAAc,GAAG,KAAKzB,iBAAL,EAArB;AACA,QAAIkC,uBAAuB,GAAG,KAAK3B,0BAAL,EAA9B;;AACA,QAAI0B,UAAJ,EAAgB;AACZ,UAAIE,UAAU,GAAG9F,KAAK,CAAC+F,SAAN,CAAgBF,uBAAuB,CAACxF,GAAxB,CAA4B,UAAU2F,CAAV,EAAa;AAAE,eAAO,CAACA,CAAC,CAACT,cAAH,EAAmB,CAAnB,CAAP;AAA+B,OAA1E,CAAhB,CAAjB;AACAM,MAAAA,uBAAuB,CAACnE,OAAxB,CAAgC,UAAUsE,CAAV,EAAa;AACzCZ,QAAAA,cAAc,CAAC1D,OAAf,CAAuB,UAAUe,IAAV,EAAgB;AACnCqD,UAAAA,UAAU,CAACE,CAAC,CAACT,cAAH,CAAV,IAAgCS,CAAC,CAACvD,IAAD,CAAjC;AACH,SAFD;AAGH,OAJD,EAFY,CAOZ;;AACAoD,MAAAA,uBAAuB,CAACnE,OAAxB,CAAgC,UAAUsE,CAAV,EAAa;AACzCZ,QAAAA,cAAc,CAAC1D,OAAf,CAAuB,UAAUe,IAAV,EAAgB;AACnCuD,UAAAA,CAAC,CAACvD,IAAD,CAAD,GAAWuD,CAAC,CAACvD,IAAD,CAAD,GAAUqD,UAAU,CAACE,CAAC,CAACT,cAAH,CAArB,GAA2C,GAArD;AACH,SAFD;AAGH,OAJD;AAKH;;AACD,WAAOjF,KAAK,GACPmB,IADE,CACG2D,cADH,EACmBS,uBADnB,EAEFxF,GAFE,CAEE,UAAU4F,MAAV,EAAkBC,CAAlB,EAAqB;AAC1B;AACA,aAAO1E,MAAM,CAACC,IAAP,CAAYwE,MAAZ,EACFhE,MADE,CACK,UAAUoD,GAAV,EAAe;AAAE,eAAO,CAACc,KAAK,CAACd,GAAD,CAAb;AAAqB,OAD3C,EAEFhF,GAFE,CAEE,UAAUgF,GAAV,EAAe;AACpB,YAAIe,OAAO,GAAGH,MAAM,CAACZ,GAAD,CAApB;AACAe,QAAAA,OAAO,CAACjF,WAAD,CAAP,GAAuBiE,cAAc,CAACc,CAAD,CAArC;AACA,eAAOE,OAAP;AACH,OANM,CAAP;AAOH,KAXM,CAAP;AAYH,GAhCD;AAiCA;;;;;AAGA7F,EAAAA,UAAU,CAACK,SAAX,CAAqBQ,UAArB,GAAkC,YAAY;AAC1C,WAAO,KAAKX,KAAL,CAAWC,OAAlB;AACH,GAFD;;AAGAH,EAAAA,UAAU,CAACK,SAAX,CAAqB4C,GAArB,GAA2B,UAAU6C,QAAV,EAAoBC,UAApB,EAAgC;AACvD,QAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,SAAK7F,KAAL,GAAae,MAAM,CAAC+E,MAAP,CAAc,EAAd,EAAkB,KAAK9F,KAAvB,EAA8B4F,QAA9B,CAAb;;AACA,QAAI,CAACC,UAAL,EAAiB;AACb,WAAKE,MAAL;AACH;AACJ,GAND;;AAOAjG,EAAAA,UAAU,CAACK,SAAX,CAAqBE,GAArB,GAA2B,UAAU2F,QAAV,EAAoB;AAC3C,QAAIA,QAAJ,EAAc;AACV,aAAO,KAAKhG,KAAL,CAAWgG,QAAX,CAAP;AACH,KAFD,MAGK;AACD,aAAO,KAAKhG,KAAZ;AACH;AACJ,GAPD;AAQA;;;;;;AAIAF,EAAAA,UAAU,CAACK,SAAX,CAAqB8F,UAArB,GAAkC,UAAUC,UAAV,EAAsB;AACpD,SAAKnD,GAAL,CAAS;AACL9C,MAAAA,OAAO,EAAEV,KAAK,CAAC4G,KAAN,CAAY,KAAKxF,UAAL,EAAZ,EAA+BuF,UAA/B;AADJ,KAAT;AAGH,GAJD;AAKA;;;;;;;AAKApG,EAAAA,UAAU,CAACK,SAAX,CAAqB4F,MAArB,GAA8B,YAAY;AACtC,QAAI,CAAC,KAAK9D,cAAL,EAAL,EAA4B;AACxB;AACH;;AACD,SAAKmE,mBAAL;AACA,SAAKC,aAAL;AACA,SAAKtG,QAAL,CAAcuG,MAAd,CAAqBC,aAArB,CAAmC9G,MAAM,CAAC+G,KAAP,CAAaC,MAAhD;AACH,GAPD;;AAQA3G,EAAAA,UAAU,CAACK,SAAX,CAAqBuG,iBAArB,GAAyC,UAAUC,EAAV,EAAc;AACnD,SAAKC,cAAL,GAAsBD,EAAtB;AACH,GAFD;AAGA;;;;;AAGA7G,EAAAA,UAAU,CAACK,SAAX,CAAqB0G,eAArB,GAAuC,UAAUC,YAAV,EAAwB;AAC3D,QAAInF,EAAE,GAAGrC,aAAa,CAAC6C,MAAd,CAAqBC,KAArB,CAA2BC,MAApC;AAAA,QAA4CH,MAAM,GAAGP,EAAE,CAACO,MAAxD;AAAA,QAAgE6E,QAAQ,GAAGpF,EAAE,CAACoF,QAA9E;AACA,QAAIzG,UAAU,GAAG,KAAKC,aAAL,EAAjB;AACA,QAAIyG,mBAAmB,GAAG1G,UAAU,CAAC2G,IAAX,CAAgB,UAAUlF,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACM,MAAN,KAAiB0E,QAAxB;AAAmC,KAAtE,CAA1B;AACA,QAAIG,WAAW,GAAG5G,UAAU,CAACkB,MAAX,CAAkB,UAAUO,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACM,MAAN,KAAiBH,MAAxB;AAAiC,KAAtE,CAAlB,CAJ2D,CAK3D;;AACA,QAAI8E,mBAAJ,EAAyB;AACrB;AACA;AACA,UAAIE,WAAW,CAACzE,MAAZ,KAAuB,CAAvB,IACAyE,WAAW,CAAC,CAAD,CAAX,CAAelF,IAAf,KAAwB8E,YAD5B,EAC0C;AACtC;AACAxG,QAAAA,UAAU,CAACW,OAAX,CAAmB,UAAUc,KAAV,EAAiB0D,CAAjB,EAAoB;AACnCnF,UAAAA,UAAU,CAACmF,CAAD,CAAV,CAAcpD,MAAd,GAAuBH,MAAvB;AACH,SAFD;AAGH,OAND,MAOK;AACD,YAAIiF,aAAa,GAAG7G,UAAU,CAAC8G,SAAX,CAAqB,UAAUrF,KAAV,EAAiB;AAAE,iBAAOA,KAAK,CAACC,IAAN,KAAe8E,YAAtB;AAAqC,SAA7E,CAApB;AACAxG,QAAAA,UAAU,CAAC6G,aAAD,CAAV,CAA0B9E,MAA1B,GACI/B,UAAU,CAAC6G,aAAD,CAAV,CAA0B9E,MAA1B,KAAqC0E,QAArC,GACM7E,MADN,GAEM6E,QAHV;AAIH;AACJ,KAjBD,MAkBK;AACD;AACAzG,MAAAA,UAAU,CAACW,OAAX,CAAmB,UAAUc,KAAV,EAAiB0D,CAAjB,EAAoB;AACnCnF,QAAAA,UAAU,CAACmF,CAAD,CAAV,CAAcpD,MAAd,GACIN,KAAK,CAACC,IAAN,KAAe8E,YAAf,GAA8B5E,MAA9B,GAAuC6E,QAD3C;AAEH,OAHD;AAIH,KA9B0D,CA+B3D;;;AACA,QAAIM,kBAAkB,GAAG/G,UAAU,CAACkB,MAAX,CAAkB,UAAUO,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACM,MAAN,KAAiBH,MAAxB;AAAiC,KAAtE,CAAzB;AACA,QAAIjC,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAI2G,0BAA0B,GAAGhH,UAAU,CAAC2G,IAAX,CAAgB,UAAUlF,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACM,MAAN,KAAiB0E,QAAxB;AAAmC,KAAtE,CAAjC,CAlC2D,CAmC3D;;AACA,QAAIO,0BAAJ,EAAgC;AAC5BrH,MAAAA,OAAO,CAACW,IAAR,CAAa2G,cAAb,GAA8BF,kBAAkB,CAACzH,GAAnB,CAAuB,UAAU4H,UAAV,EAAsB;AAAE,eAAOA,UAAU,CAACxF,IAAlB;AAAyB,OAAxE,CAA9B;AACH,KAFD,MAGK;AACD;AACA/B,MAAAA,OAAO,CAACW,IAAR,CAAa2G,cAAb,GAA8B,EAA9B;AACH,KA1C0D,CA2C3D;;;AACA,SAAKxH,QAAL,CAAcuG,MAAd,CAAqBC,aAArB,CAAmC9G,MAAM,CAACgI,MAAP,CAAcC,YAAjD,EAA+D;AAC3DpH,MAAAA,UAAU,EAAEA;AAD+C,KAA/D,EA5C2D,CA+C3D;;AACA,SAAKyC,GAAL,CAAS;AACLzC,MAAAA,UAAU,EAAEA;AADP,KAAT;AAGH,GAnDD;AAoDA;;;;;;;;;AAOAR,EAAAA,UAAU,CAACK,SAAX,CAAqBwH,WAArB,GAAmC,UAAU5F,KAAV,EAAiB6C,GAAjB,EAAsBhE,IAAtB,EAA4BgH,aAA5B,EAA2C;AAC1E,QAAI3H,OAAO,GAAG,KAAKU,UAAL,EAAd;;AACA,QAAIV,OAAO,CAAC0H,WAAZ,EAAyB;AACrB,aAAO1H,OAAO,CAAC0H,WAAR,CAAoB5F,KAApB,EAA2B6C,GAA3B,EAAgChE,IAAhC,EAAsCgH,aAAtC,CAAP;AACH,KAFD,MAGK;AACD,aAAOA,aAAP;AACH;AACJ,GARD;;AASA9H,EAAAA,UAAU,CAACK,SAAX,CAAqB0H,YAArB,GAAoC,UAAU9F,KAAV,EAAiB6C,GAAjB,EAAsBhE,IAAtB,EAA4B;AAC5D,QAAIX,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAImH,gBAAgB,GAAG,KAAKC,YAAL,GAAoBhG,KAApB,CAAvB;;AACA,QAAI9B,OAAO,CAAC4H,YAAZ,EAA0B;AACtB,aAAO5H,OAAO,CAAC4H,YAAR,CAAqB9F,KAArB,EAA4B6C,GAA5B,EAAiChE,IAAjC,EAAuCkH,gBAAvC,CAAP;AACH,KAFD,MAGK;AACD,aAAOA,gBAAP;AACH;AACJ,GATD;;AAUAhI,EAAAA,UAAU,CAACK,SAAX,CAAqB6H,cAArB,GAAsC,UAAUjG,KAAV,EAAiB6C,GAAjB,EAAsBhE,IAAtB,EAA4B;AAC9D,QAAIX,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAIsH,kBAAkB,GAAG,KAAK/H,UAAL,CAAgB6B,KAAhB,CAAzB;;AACA,QAAI9B,OAAO,CAAC+H,cAAZ,EAA4B;AACxB,aAAO/H,OAAO,CAAC+H,cAAR,CAAuBjG,KAAvB,EAA8B6C,GAA9B,EAAmChE,IAAnC,EAAyCqH,kBAAzC,CAAP;AACH,KAFD,MAGK;AACD,aAAOA,kBAAP;AACH;AACJ,GATD;;AAUAnI,EAAAA,UAAU,CAACK,SAAX,CAAqB4H,YAArB,GAAoC,YAAY;AAC5C,WAAO,KAAK7H,UAAZ;AACH,GAFD;AAGA;;;;;AAGAJ,EAAAA,UAAU,CAACK,SAAX,CAAqB+H,SAArB,GAAiC,YAAY;AACzC,WAAO,IAAP;AACH,GAFD;AAGA;;;;;;AAIApI,EAAAA,UAAU,CAACK,SAAX,CAAqBgI,sBAArB,GAA8C,UAAUvH,IAAV,EAAgB;AAC1DwH,IAAAA,OAAO,CAACC,IAAR,CAAa,6PAAb;AACA,QAAIC,WAAW,GAAG,EAAlB;AACA,QAAIC,QAAQ,GAAG3H,IAAI,CAAC2H,QAApB;AAAA,QAA8BC,MAAM,GAAG5H,IAAI,CAAC4H,MAA5C,CAH0D,CAI1D;;AACAD,IAAAA,QAAQ,CAACtH,OAAT,CAAiB,UAAUwH,OAAV,EAAmB;AAChC;AACAA,MAAAA,OAAO,CAAC7H,IAAR,CAAaK,OAAb,CAAqB,UAAUQ,KAAV,EAAiBgE,CAAjB,EAAoB;AACrC,YAAI1D,KAAJ;AACA,YAAI2G,YAAY,GAAGnJ,KAAK,CAACoJ,WAAN,CAAkBF,OAAlB,EAA2B,OAA3B,CAAnB;;AACA,YAAIC,YAAY,KAAK,IAArB,EAA2B;AACvB,cAAIE,kBAAkB,GAAGrJ,KAAK,CAACoJ,WAAN,CAAkBH,MAAlB,EAA0B/C,CAA1B,CAAzB;;AACA,cAAImD,kBAAJ,EAAwB;AACpB7G,YAAAA,KAAK,GAAG6G,kBAAR;AACH,WAFD,MAGK;AACD7G,YAAAA,KAAK,GAAG,WAAR;AACH;AACJ,SARD,MASK;AACDA,UAAAA,KAAK,GAAG2G,YAAR;AACH;;AACD,YAAIG,YAAY,GAAG;AACf9G,UAAAA,KAAK,EAAEA,KADQ;AAEf6C,UAAAA,GAAG,EAAE4D,MAAM,CAAC/C,CAAD;AAFI,SAAnB;;AAIA,YAAIC,KAAK,CAACjE,KAAD,CAAT,EAAkB;AACdoH,UAAAA,YAAY,CAAC,OAAD,CAAZ,GAAwBpH,KAAK,CAACqH,KAA9B;AACAD,UAAAA,YAAY,CAAC,MAAD,CAAZ,GAAuBpH,KAAK,CAACsH,IAA7B;AACH,SAHD,MAIK;AACDF,UAAAA,YAAY,CAAC,OAAD,CAAZ,GAAwBpH,KAAxB;AACH;;AACD6G,QAAAA,WAAW,CAAC/E,IAAZ,CAAiBsF,YAAjB;AACH,OA3BD;AA4BH,KA9BD;AA+BA,WAAOP,WAAP;AACH,GArCD;;AAsCAxI,EAAAA,UAAU,CAACK,SAAX,CAAqB6I,cAArB,GAAsC,UAAUpI,IAAV,EAAgB;AAClD;AACA,QAAI,CAACqI,KAAK,CAACC,OAAN,CAActI,IAAd,CAAL,EAA0B;AACtB,aAAO,KAAKuH,sBAAL,CAA4BvH,IAA5B,CAAP;AACH;;AACD,WAAOA,IAAP;AACH,GAND;;AAOAd,EAAAA,UAAU,CAACK,SAAX,CAAqB0C,QAArB,GAAgC,UAAUjC,IAAV,EAAgB;AAC5C,WAAO,KAAKoI,cAAL,CAAoBpI,IAApB,CAAP;AACH,GAFD;AAGA;;;;;AAGAd,EAAAA,UAAU,CAACK,SAAX,CAAqBiG,mBAArB,GAA2C,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA,QAAI+C,KAAK,GAAG,IAAZ,CANmD,CAOnD;AACA;;;AACA,QAAI,CAAC,KAAKC,aAAV,EAAyB;AACrB,WAAKA,aAAL,GAAqB,KAAKlG,iBAAL,EAArB;AACH,KAFD,MAGK;AACD;AACA,WAAKA,iBAAL,GAAyBjC,OAAzB,CAAiC,UAAU8D,aAAV,EAAyB;AACtD;AACA,YAAIoE,KAAK,CAACC,aAAN,CAAoBC,OAApB,CAA4BtE,aAA5B,MAA+C,CAAC,CAApD,EAAuD;AACnDoE,UAAAA,KAAK,CAACC,aAAN,CAAoB7F,IAApB,CAAyBwB,aAAzB;AACH;AACJ,OALD;AAMH;AACJ,GArBD;;AAsBAjF,EAAAA,UAAU,CAACK,SAAX,CAAqB2C,kBAArB,GAA0C,UAAUlC,IAAV,EAAgB;AACtD,QAAIF,WAAW,GAAG,KAAKC,UAAL,GAAkBC,IAAlB,CAAuBF,WAAzC;AACA,QAAIiB,EAAE,GAAGrC,aAAa,CAAC6C,MAAd,CAAqBC,KAArB,CAA2BC,MAApC;AAAA,QAA4CH,MAAM,GAAGP,EAAE,CAACO,MAAxD;AAAA,QAAgE6E,QAAQ,GAAGpF,EAAE,CAACoF,QAA9E;AACA,QAAI9G,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAI2I,gBAAgB,GAAG1J,GAAG,CAACgB,IAAD,EAAO,UAAUa,KAAV,EAAiB;AAAE,aAAOA,KAAK,CAACf,WAAD,CAAZ;AAA4B,KAAtD,CAAH,CAA2DM,IAA3D,EAAvB,CAJsD,CAKtD;;AACA,QAAIf,OAAO,CAACW,IAAR,CAAa2G,cAAb,CAA4B9E,MAAhC,EAAwC;AACpC,UAAI8G,oBAAoB,GAAGtJ,OAAO,CAACW,IAAR,CAAa2G,cAAb,CAA4BiC,KAA5B,CAAkC,UAAUhG,SAAV,EAAqB;AAAE,eAAO8F,gBAAgB,CAAC5H,QAAjB,CAA0B8B,SAA1B,CAAP;AAA8C,OAAvG,CAA3B;;AACA,UAAI,CAAC+F,oBAAL,EAA2B;AACvBtJ,QAAAA,OAAO,CAACW,IAAR,CAAa2G,cAAb,GAA8B,EAA9B;AACH;AACJ,KAXqD,CAYtD;;;AACA,QAAIW,SAAS,GAAG,UAAU1E,SAAV,EAAqB;AACjC,aAAO,CAACvD,OAAO,CAACW,IAAR,CAAa2G,cAAb,CAA4B9E,MAA7B,IACHxC,OAAO,CAACW,IAAR,CAAa2G,cAAb,CAA4B7F,QAA5B,CAAqC8B,SAArC,CADG,GAEDtB,MAFC,GAGD6E,QAHN;AAIH,KALD;;AAMA,WAAOuC,gBAAgB,CAAC1J,GAAjB,CAAqB,UAAU4D,SAAV,EAAqB;AAAE,aAAQ;AACvDxB,QAAAA,IAAI,EAAEwB,SADiD;AAEvDnB,QAAAA,MAAM,EAAE6F,SAAS,CAAC1E,SAAD;AAFsC,OAAR;AAG9C,KAHE,CAAP;AAIH,GAvBD;AAwBA;;;;;AAGA1D,EAAAA,UAAU,CAACK,SAAX,CAAqBkG,aAArB,GAAqC,YAAY;AAC7C,QAAIoD,aAAa,GAAGjK,aAAa,CAACkK,OAAlC;AACA,QAAIzJ,OAAO,GAAG,KAAKU,UAAL,EAAd;AACA,QAAIgJ,iBAAiB,GAAGpK,KAAK,CAACoJ,WAAN,CAAkB1I,OAAlB,EAA2B,OAA3B,EAAoC,OAApC,CAAxB,CAH6C,CAI7C;;AACA,QAAI0J,iBAAiB,KAAK,IAAtB,IACA5I,MAAM,CAACC,IAAP,CAAY2I,iBAAZ,EAA+BlH,MAA/B,KAA0C,CAD9C,EACiD;AAC7C,WAAKvC,UAAL,GAAkBP,YAAY,GACzBiK,KADa,CACPH,aADO,EAEbrI,MAFa,CAEN,KAAKgI,aAFC,CAAlB;AAGA;AACH;AACD;;;;;;;AAKA,QAAIS,UAAU,GAAG,EAAjB;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,SAAKV,aAAL,CAAmBnI,OAAnB,CAA2B,UAAUgC,SAAV,EAAqB;AAC5C,UAAI0G,iBAAiB,CAAC1G,SAAD,CAArB,EAAkC;AAC9B4G,QAAAA,UAAU,CAACtG,IAAX,CAAgBoG,iBAAiB,CAAC1G,SAAD,CAAjC;AACH,OAFD,MAGK;AACD4G,QAAAA,UAAU,CAACtG,IAAX,CAAgBkG,aAAa,CAACK,UAAD,CAA7B;AACH;;AACD,UAAIA,UAAU,KAAKL,aAAa,CAAChH,MAAd,GAAuB,CAA1C,EAA6C;AACzCqH,QAAAA,UAAU,GAAG,CAAb;AACH,OAFD,MAGK;AACDA,QAAAA,UAAU;AACb;AACJ,KAbD;AAcA,SAAK5J,UAAL,GAAkBP,YAAY,GACzBiK,KADa,CACPC,UADO,EAEbzI,MAFa,CAEN,KAAKgI,aAFC,CAAlB;AAGH,GApCD;;AAqCA,SAAOtJ,UAAP;AACH,CAhd+B,EAAhC;;AAidA,SAASA,UAAT","sourcesContent":["// Internal Imports\nimport * as Configuration from \"./configuration\";\nimport { Tools } from \"./tools\";\nimport * as colorPalettes from \"./services/colorPalettes\";\nimport { Events, ScaleTypes } from \"./interfaces\";\n// D3\nimport { scaleOrdinal } from \"d3-scale\";\nimport { map } from \"d3-collection\";\nimport { stack } from \"d3-shape\";\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nvar ChartModel = /** @class */ (function () {\n    function ChartModel(services) {\n        // Internal Model state\n        this.state = {\n            options: {}\n        };\n        // Fill scales & fill related objects\n        this.colorScale = {};\n        this.services = services;\n    }\n    ChartModel.prototype.getAllDataFromDomain = function () {\n        if (!this.get(\"data\")) {\n            return null;\n        }\n        var dataGroups = this.getDataGroups();\n        // Remove datasets that have been disabled\n        var displayData = Tools.clone(this.get(\"data\"));\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        var axesOptions = this.getOptions().axes;\n        // Check for custom domain\n        if (axesOptions) {\n            Object.keys(axesOptions).forEach(function (axis) {\n                if (axesOptions[axis].mapsTo && axesOptions[axis].domain) {\n                    var mapsTo_1 = axesOptions[axis].mapsTo;\n                    if (axesOptions[axis].scaleType === ScaleTypes.LABELS) {\n                        displayData = displayData.filter(function (datum) {\n                            return axesOptions[axis].domain.includes(datum[mapsTo_1]);\n                        });\n                    }\n                    else {\n                        var _a = axesOptions[axis].domain, start_1 = _a[0], end_1 = _a[1];\n                        // Filter out data outside domain\n                        displayData = displayData.filter(function (datum) {\n                            return datum[mapsTo_1] >= start_1 && datum[mapsTo_1] <= end_1;\n                        });\n                    }\n                }\n            });\n        }\n        return displayData.filter(function (datum) {\n            return dataGroups.find(function (group) { return group.name === datum[groupMapsTo]; });\n        });\n    };\n    ChartModel.prototype.getDisplayData = function () {\n        if (!this.get(\"data\")) {\n            return null;\n        }\n        var ACTIVE = Configuration.legend.items.status.ACTIVE;\n        var dataGroups = this.getDataGroups();\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        var allDataFromDomain = this.getAllDataFromDomain();\n        return allDataFromDomain.filter(function (datum) {\n            var group = dataGroups.find(function (group) { return group.name === datum[groupMapsTo]; });\n            return group.status === ACTIVE;\n        });\n    };\n    ChartModel.prototype.getData = function () {\n        return this.get(\"data\");\n    };\n    ChartModel.prototype.isDataEmpty = function () {\n        return !this.getData().length;\n    };\n    /**\n     *\n     * @param newData The new raw data to be set\n     */\n    ChartModel.prototype.setData = function (newData) {\n        var sanitizedData = this.sanitize(Tools.clone(newData));\n        var dataGroups = this.generateDataGroups(sanitizedData);\n        this.set({\n            data: sanitizedData,\n            dataGroups: dataGroups\n        });\n        return sanitizedData;\n    };\n    ChartModel.prototype.getDataGroups = function () {\n        return this.get(\"dataGroups\");\n    };\n    ChartModel.prototype.getActiveDataGroups = function () {\n        var ACTIVE = Configuration.legend.items.status.ACTIVE;\n        return this.getDataGroups().filter(function (dataGroup) { return dataGroup.status === ACTIVE; });\n    };\n    ChartModel.prototype.getDataGroupNames = function () {\n        return this.getDataGroups().map(function (dataGroup) { return dataGroup.name; });\n    };\n    ChartModel.prototype.getActiveDataGroupNames = function () {\n        return this.getActiveDataGroups().map(function (dataGroup) { return dataGroup.name; });\n    };\n    ChartModel.prototype.getGroupedData = function () {\n        var displayData = this.getDisplayData();\n        var groupedData = {};\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        displayData.map(function (datum) {\n            var group = datum[groupMapsTo];\n            if (groupedData[group] !== null &&\n                groupedData[group] !== undefined) {\n                groupedData[group].push(datum);\n            }\n            else {\n                groupedData[group] = [datum];\n            }\n        });\n        return Object.keys(groupedData).map(function (groupName) { return ({\n            name: groupName,\n            data: groupedData[groupName]\n        }); });\n    };\n    ChartModel.prototype.getDataValuesGroupedByKeys = function () {\n        var options = this.getOptions();\n        var groupMapsTo = options.data.groupMapsTo;\n        var displayData = this.getDisplayData();\n        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();\n        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();\n        var stackKeys = map(displayData, function (datum) { return datum[domainIdentifier]; }).keys();\n        var axisPosition = this.services.cartesianScales.domainAxisPosition;\n        var scaleType = options.axes[axisPosition].scaleType;\n        // Sort keys\n        if (scaleType === ScaleTypes.TIME) {\n            stackKeys.sort(function (a, b) {\n                var dateA = new Date(a);\n                var dateB = new Date(b);\n                return dateA - dateB;\n            });\n        }\n        else if (scaleType === ScaleTypes.LOG ||\n            scaleType === ScaleTypes.LINEAR) {\n            stackKeys.sort(function (a, b) { return a - b; });\n        }\n        var dataGroupNames = this.getDataGroupNames();\n        return stackKeys.map(function (key) {\n            var correspondingValues = { sharedStackKey: key };\n            dataGroupNames.forEach(function (dataGroupName) {\n                var correspondingDatum = displayData.find(function (datum) {\n                    return (datum[groupMapsTo] === dataGroupName &&\n                        datum[domainIdentifier].toString() === key);\n                });\n                correspondingValues[dataGroupName] = correspondingDatum\n                    ? correspondingDatum[rangeIdentifier]\n                    : null;\n            });\n            return correspondingValues;\n        });\n    };\n    ChartModel.prototype.getStackedData = function (_a) {\n        var percentage = (_a === void 0 ? { percentage: false } : _a).percentage;\n        var options = this.getOptions();\n        var groupMapsTo = options.data.groupMapsTo;\n        var dataGroupNames = this.getDataGroupNames();\n        var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys();\n        if (percentage) {\n            var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function (d) { return [d.sharedStackKey, 0]; }));\n            dataValuesGroupedByKeys.forEach(function (d) {\n                dataGroupNames.forEach(function (name) {\n                    maxByKey_1[d.sharedStackKey] += d[name];\n                });\n            });\n            // cycle through data values to get percentage\n            dataValuesGroupedByKeys.forEach(function (d) {\n                dataGroupNames.forEach(function (name) {\n                    d[name] = (d[name] / maxByKey_1[d.sharedStackKey]) * 100;\n                });\n            });\n        }\n        return stack()\n            .keys(dataGroupNames)(dataValuesGroupedByKeys)\n            .map(function (series, i) {\n            // Add data group names to each series\n            return Object.keys(series)\n                .filter(function (key) { return !isNaN(key); })\n                .map(function (key) {\n                var element = series[key];\n                element[groupMapsTo] = dataGroupNames[i];\n                return element;\n            });\n        });\n    };\n    /**\n     * @return {Object} The chart's options\n     */\n    ChartModel.prototype.getOptions = function () {\n        return this.state.options;\n    };\n    ChartModel.prototype.set = function (newState, skipUpdate) {\n        if (skipUpdate === void 0) { skipUpdate = false; }\n        this.state = Object.assign({}, this.state, newState);\n        if (!skipUpdate) {\n            this.update();\n        }\n    };\n    ChartModel.prototype.get = function (property) {\n        if (property) {\n            return this.state[property];\n        }\n        else {\n            return this.state;\n        }\n    };\n    /**\n     *\n     * @param newOptions New options to be set\n     */\n    ChartModel.prototype.setOptions = function (newOptions) {\n        this.set({\n            options: Tools.merge(this.getOptions(), newOptions)\n        });\n    };\n    /**\n     *\n     * Updates miscellanous information within the model\n     * such as the color scales, or the legend data labels\n     */\n    ChartModel.prototype.update = function () {\n        if (!this.getDisplayData()) {\n            return;\n        }\n        this.updateAllDataGroups();\n        this.setColorScale();\n        this.services.events.dispatchEvent(Events.Model.UPDATE);\n    };\n    ChartModel.prototype.setUpdateCallback = function (cb) {\n        this.updateCallback = cb;\n    };\n    /*\n     * Data labels\n     */\n    ChartModel.prototype.toggleDataLabel = function (changedLabel) {\n        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;\n        var dataGroups = this.getDataGroups();\n        var hasDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });\n        var activeItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });\n        // If there are deactivated items, toggle \"changedLabel\"\n        if (hasDeactivatedItems) {\n            // If the only active item is being toggled\n            // Activate all items\n            if (activeItems.length === 1 &&\n                activeItems[0].name === changedLabel) {\n                // If every item is active, then enable \"changedLabel\" and disable all other items\n                dataGroups.forEach(function (group, i) {\n                    dataGroups[i].status = ACTIVE;\n                });\n            }\n            else {\n                var indexToChange = dataGroups.findIndex(function (group) { return group.name === changedLabel; });\n                dataGroups[indexToChange].status =\n                    dataGroups[indexToChange].status === DISABLED\n                        ? ACTIVE\n                        : DISABLED;\n            }\n        }\n        else {\n            // If every item is active, then enable \"changedLabel\" and disable all other items\n            dataGroups.forEach(function (group, i) {\n                dataGroups[i].status =\n                    group.name === changedLabel ? ACTIVE : DISABLED;\n            });\n        }\n        // Updates selected groups\n        var updatedActiveItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });\n        var options = this.getOptions();\n        var hasUpdatedDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });\n        // If there are deactivated items, map the item name into selected groups\n        if (hasUpdatedDeactivatedItems) {\n            options.data.selectedGroups = updatedActiveItems.map(function (activeItem) { return activeItem.name; });\n        }\n        else {\n            // If every item is active, clear array\n            options.data.selectedGroups = [];\n        }\n        // dispatch legend filtering event with the status of all the dataLabels\n        this.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n            dataGroups: dataGroups\n        });\n        // Update model\n        this.set({\n            dataGroups: dataGroups\n        });\n    };\n    /**\n     * Should the data point be filled?\n     * @param group\n     * @param key\n     * @param value\n     * @param defaultFilled the default for this chart\n     */\n    ChartModel.prototype.getIsFilled = function (group, key, data, defaultFilled) {\n        var options = this.getOptions();\n        if (options.getIsFilled) {\n            return options.getIsFilled(group, key, data, defaultFilled);\n        }\n        else {\n            return defaultFilled;\n        }\n    };\n    ChartModel.prototype.getFillColor = function (group, key, data) {\n        var options = this.getOptions();\n        var defaultFillColor = this.getFillScale()(group);\n        if (options.getFillColor) {\n            return options.getFillColor(group, key, data, defaultFillColor);\n        }\n        else {\n            return defaultFillColor;\n        }\n    };\n    ChartModel.prototype.getStrokeColor = function (group, key, data) {\n        var options = this.getOptions();\n        var defaultStrokeColor = this.colorScale(group);\n        if (options.getStrokeColor) {\n            return options.getStrokeColor(group, key, data, defaultStrokeColor);\n        }\n        else {\n            return defaultStrokeColor;\n        }\n    };\n    ChartModel.prototype.getFillScale = function () {\n        return this.colorScale;\n    };\n    /**\n     * For charts that might hold an associated status for their dataset\n     */\n    ChartModel.prototype.getStatus = function () {\n        return null;\n    };\n    /**\n     * Converts data provided in the older format to tabular\n     *\n     */\n    ChartModel.prototype.transformToTabularData = function (data) {\n        console.warn(\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/tutorials--tabular-data-format\");\n        var tabularData = [];\n        var datasets = data.datasets, labels = data.labels;\n        // Loop through all datasets\n        datasets.forEach(function (dataset) {\n            // Update each data point to the new format\n            dataset.data.forEach(function (datum, i) {\n                var group;\n                var datasetLabel = Tools.getProperty(dataset, \"label\");\n                if (datasetLabel === null) {\n                    var correspondingLabel = Tools.getProperty(labels, i);\n                    if (correspondingLabel) {\n                        group = correspondingLabel;\n                    }\n                    else {\n                        group = \"Ungrouped\";\n                    }\n                }\n                else {\n                    group = datasetLabel;\n                }\n                var updatedDatum = {\n                    group: group,\n                    key: labels[i]\n                };\n                if (isNaN(datum)) {\n                    updatedDatum[\"value\"] = datum.value;\n                    updatedDatum[\"date\"] = datum.date;\n                }\n                else {\n                    updatedDatum[\"value\"] = datum;\n                }\n                tabularData.push(updatedDatum);\n            });\n        });\n        return tabularData;\n    };\n    ChartModel.prototype.getTabularData = function (data) {\n        // if data is not an array\n        if (!Array.isArray(data)) {\n            return this.transformToTabularData(data);\n        }\n        return data;\n    };\n    ChartModel.prototype.sanitize = function (data) {\n        return this.getTabularData(data);\n    };\n    /*\n     * Data groups\n     */\n    ChartModel.prototype.updateAllDataGroups = function () {\n        // allDataGroups is used to generate a color scale that applies\n        // to all the groups. Now when the data updates, you might remove a group,\n        // and then bring it back in a newer data update, therefore\n        // the order of the groups in allDataGroups matters so that you'd never\n        // have an incorrect color assigned to a group.\n        var _this = this;\n        // Also, a new group should only be added to allDataGroups if\n        // it doesn't currently exist\n        if (!this.allDataGroups) {\n            this.allDataGroups = this.getDataGroupNames();\n        }\n        else {\n            // Loop through current data groups\n            this.getDataGroupNames().forEach(function (dataGroupName) {\n                // If group name hasn't been stored yet, store it\n                if (_this.allDataGroups.indexOf(dataGroupName) === -1) {\n                    _this.allDataGroups.push(dataGroupName);\n                }\n            });\n        }\n    };\n    ChartModel.prototype.generateDataGroups = function (data) {\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;\n        var options = this.getOptions();\n        var uniqueDataGroups = map(data, function (datum) { return datum[groupMapsTo]; }).keys();\n        // check if selectedGroups can be applied to chart with current data groups\n        if (options.data.selectedGroups.length) {\n            var hasAllSelectedGroups = options.data.selectedGroups.every(function (groupName) { return uniqueDataGroups.includes(groupName); });\n            if (!hasAllSelectedGroups) {\n                options.data.selectedGroups = [];\n            }\n        }\n        // Get group status based on items in selected groups\n        var getStatus = function (groupName) {\n            return !options.data.selectedGroups.length ||\n                options.data.selectedGroups.includes(groupName)\n                ? ACTIVE\n                : DISABLED;\n        };\n        return uniqueDataGroups.map(function (groupName) { return ({\n            name: groupName,\n            status: getStatus(groupName)\n        }); });\n    };\n    /*\n     * Fill scales\n     */\n    ChartModel.prototype.setColorScale = function () {\n        var defaultColors = colorPalettes.DEFAULT;\n        var options = this.getOptions();\n        var userProvidedScale = Tools.getProperty(options, \"color\", \"scale\");\n        // If there is no valid user provided scale, use the default set of colors\n        if (userProvidedScale === null ||\n            Object.keys(userProvidedScale).length === 0) {\n            this.colorScale = scaleOrdinal()\n                .range(defaultColors)\n                .domain(this.allDataGroups);\n            return;\n        }\n        /**\n         * Go through allDataGroups. If a data group has a color value provided\n         * by the user, add that to the color range\n         * If not, add a default color\n         */\n        var colorRange = [];\n        var colorIndex = 0;\n        this.allDataGroups.forEach(function (dataGroup) {\n            if (userProvidedScale[dataGroup]) {\n                colorRange.push(userProvidedScale[dataGroup]);\n            }\n            else {\n                colorRange.push(defaultColors[colorIndex]);\n            }\n            if (colorIndex === defaultColors.length - 1) {\n                colorIndex = 0;\n            }\n            else {\n                colorIndex++;\n            }\n        });\n        this.colorScale = scaleOrdinal()\n            .range(colorRange)\n            .domain(this.allDataGroups);\n    };\n    return ChartModel;\n}());\nexport { ChartModel };\n//# sourceMappingURL=../src/model.js.map"]},"metadata":{},"sourceType":"module"}