var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Internal Imports
import * as Configuration from "../configuration";
import { Service } from "./service";
import { AxisPositions, CartesianOrientations, ScaleTypes } from "../interfaces";
import { Tools } from "../tools";
// D3 Imports
import { scaleBand, scaleLinear, scaleTime, scaleLog } from "d3-scale";
import { extent, sum } from "d3-array";
import { map, values } from "d3-collection";
// Misc
import { differenceInYears, addYears, subYears, differenceInMonths, addMonths, subMonths, differenceInDays, addDays, subDays, differenceInHours, addHours, subHours, differenceInMinutes, addMinutes, subMinutes, differenceInSeconds, subSeconds, addSeconds } from "date-fns";
var CartesianScales = /** @class */ (function (_super) {
    __extends(CartesianScales, _super);
    function CartesianScales() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scaleTypes = {
            top: null,
            right: null,
            bottom: null,
            left: null
        };
        _this.scales = {
            top: null,
            right: null,
            bottom: null,
            left: null
        };
        return _this;
    }
    CartesianScales.prototype.getDomainAxisPosition = function () {
        return this.domainAxisPosition;
    };
    CartesianScales.prototype.getRangeAxisPosition = function () {
        return this.rangeAxisPosition;
    };
    CartesianScales.prototype.getAxisOptions = function (position) {
        return Tools.getProperty(this.model.getOptions(), "axes", position);
    };
    CartesianScales.prototype.getDomainAxisOptions = function () {
        var domainAxisPosition = this.getDomainAxisPosition();
        return this.getAxisOptions(domainAxisPosition);
    };
    CartesianScales.prototype.getRangeAxisOptions = function () {
        var rangeAxisPosition = this.getRangeAxisPosition();
        return this.getAxisOptions(rangeAxisPosition);
    };
    CartesianScales.prototype.update = function (animate) {
        var _this = this;
        if (animate === void 0) { animate = true; }
        this.findDomainAndRangeAxes();
        this.determineOrientation();
        var axisPositions = Object.keys(AxisPositions).map(function (axisPositionKey) { return AxisPositions[axisPositionKey]; });
        axisPositions.forEach(function (axisPosition) {
            _this.scales[axisPosition] = _this.createScale(axisPosition);
        });
    };
    CartesianScales.prototype.findDomainAndRangeAxes = function () {
        // find main axes between (left & right) && (bottom & top)
        var mainVerticalAxisPosition = this.findMainVerticalAxisPosition();
        var mainHorizontalAxisPosition = this.findMainHorizontalAxisPosition();
        // Now we have horizontal & vertical main axes to choose domain & range axes from
        var domainAndRangeAxesPositions = this.findDomainAndRangeAxesPositions(mainVerticalAxisPosition, mainHorizontalAxisPosition);
        this.domainAxisPosition =
            domainAndRangeAxesPositions.domainAxisPosition;
        this.rangeAxisPosition = domainAndRangeAxesPositions.rangeAxisPosition;
    };
    CartesianScales.prototype.determineOrientation = function () {
        if ((this.rangeAxisPosition === AxisPositions.LEFT ||
            this.rangeAxisPosition === AxisPositions.RIGHT) &&
            (this.domainAxisPosition === AxisPositions.BOTTOM ||
                this.domainAxisPosition === AxisPositions.TOP)) {
            this.orientation = CartesianOrientations.VERTICAL;
        }
        else {
            this.orientation = CartesianOrientations.HORIZONTAL;
        }
    };
    CartesianScales.prototype.getOrientation = function () {
        return this.orientation;
    };
    CartesianScales.prototype.getScaleByPosition = function (axisPosition) {
        return this.scales[axisPosition];
    };
    CartesianScales.prototype.getScaleTypeByPosition = function (axisPosition) {
        return this.scaleTypes[axisPosition];
    };
    CartesianScales.prototype.getDomainAxisScaleType = function () {
        var domainAxisPosition = this.getDomainAxisPosition();
        return this.getScaleTypeByPosition(domainAxisPosition);
    };
    CartesianScales.prototype.getRangeAxisScaleType = function () {
        var rangeAxisPosition = this.getRangeAxisPosition();
        return this.getScaleTypeByPosition(rangeAxisPosition);
    };
    CartesianScales.prototype.getDomainScale = function () {
        return this.scales[this.domainAxisPosition];
    };
    CartesianScales.prototype.getRangeScale = function () {
        return this.scales[this.rangeAxisPosition];
    };
    // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
    CartesianScales.prototype.getMainXAxisPosition = function () {
        var possibleXAxisPositions = [
            AxisPositions.BOTTOM,
            AxisPositions.TOP
        ];
        return [this.domainAxisPosition, this.rangeAxisPosition].find(function (position) { return possibleXAxisPositions.indexOf(position) > -1; });
    };
    // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
    CartesianScales.prototype.getMainYAxisPosition = function () {
        var possibleYAxisPositions = [
            AxisPositions.LEFT,
            AxisPositions.RIGHT
        ];
        return [this.domainAxisPosition, this.rangeAxisPosition].find(function (position) { return possibleYAxisPositions.indexOf(position) > -1; });
    };
    CartesianScales.prototype.getMainXScale = function () {
        return this.scales[this.getMainXAxisPosition()];
    };
    CartesianScales.prototype.getMainYScale = function () {
        return this.scales[this.getMainYAxisPosition()];
    };
    CartesianScales.prototype.getValueFromScale = function (axisPosition, datum, index) {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", axisPosition);
        var scaleType = this.scaleTypes[axisPosition];
        var scale = this.scales[axisPosition];
        var mapsTo = axisOptions.mapsTo;
        var value = datum[mapsTo] !== undefined ? datum[mapsTo] : datum;
        if (scaleType === ScaleTypes.LABELS) {
            return scale(value) + scale.step() / 2;
        }
        if (scaleType === ScaleTypes.TIME) {
            return scale(new Date(value));
        }
        return scale(value);
    };
    CartesianScales.prototype.getDomainValue = function (d, i) {
        return this.getValueFromScale(this.domainAxisPosition, d, i);
    };
    CartesianScales.prototype.getRangeValue = function (d, i) {
        return this.getValueFromScale(this.rangeAxisPosition, d, i);
    };
    CartesianScales.prototype.getDomainIdentifier = function () {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", this.domainAxisPosition);
        return axisOptions.mapsTo;
    };
    CartesianScales.prototype.getRangeIdentifier = function () {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", this.rangeAxisPosition);
        return axisOptions.mapsTo;
    };
    /** Uses the Y Axis to get data items associated with that value. */
    CartesianScales.prototype.getDataFromDomain = function (domainValue) {
        var displayData = this.model.getDisplayData();
        var domainIdentifier = this.getDomainIdentifier();
        var scaleType = this.scaleTypes[this.domainAxisPosition];
        if (scaleType === ScaleTypes.TIME) {
            return displayData.filter(function (datum) {
                var date = datum[domainIdentifier];
                if (typeof date === "string" || date.getTime === undefined) {
                    date = new Date(date);
                }
                return date.getTime() === domainValue.getTime();
            });
        }
        return displayData.filter(function (datum) {
            return datum[domainIdentifier] === domainValue;
        });
    };
    CartesianScales.prototype.extendsDomain = function (axisPosition, domain) {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", axisPosition);
        if (axisOptions.scaleType === ScaleTypes.TIME) {
            var spaceToAddToEdges = Tools.getProperty(options, "timeScale", "addSpaceOnEdges");
            return addSpacingToTimeDomain(domain, spaceToAddToEdges);
        }
        else {
            return addSpacingToContinuousDomain(domain, Configuration.axis.paddingRatio);
        }
    };
    CartesianScales.prototype.findMainVerticalAxisPosition = function () {
        var options = this.model.getOptions();
        var axesOptions = Tools.getProperty(options, "axes");
        // If right axis has been specified as `main`
        if ((Tools.getProperty(axesOptions, AxisPositions.LEFT) === null &&
            Tools.getProperty(axesOptions, AxisPositions.RIGHT) !== null) ||
            Tools.getProperty(axesOptions, AxisPositions.RIGHT, "main") === true) {
            return AxisPositions.RIGHT;
        }
        return AxisPositions.LEFT;
    };
    CartesianScales.prototype.findMainHorizontalAxisPosition = function () {
        var options = this.model.getOptions();
        var axesOptions = Tools.getProperty(options, "axes");
        // If top axis has been specified as `main`
        if ((Tools.getProperty(axesOptions, AxisPositions.BOTTOM) === null &&
            Tools.getProperty(axesOptions, AxisPositions.TOP) !== null) ||
            Tools.getProperty(axesOptions, AxisPositions.TOP, "main") === true) {
            return AxisPositions.TOP;
        }
        return AxisPositions.BOTTOM;
    };
    CartesianScales.prototype.findDomainAndRangeAxesPositions = function (mainVerticalAxisPosition, mainHorizontalAxisPosition) {
        var options = this.model.getOptions();
        var mainVerticalAxisOptions = Tools.getProperty(options, "axes", mainVerticalAxisPosition);
        var mainHorizontalAxisOptions = Tools.getProperty(options, "axes", mainHorizontalAxisPosition);
        var mainVerticalScaleType = mainVerticalAxisOptions.scaleType || ScaleTypes.LINEAR;
        var mainHorizontalScaleType = mainHorizontalAxisOptions.scaleType || ScaleTypes.LINEAR;
        var result = {
            domainAxisPosition: null,
            rangeAxisPosition: null
        };
        if (mainHorizontalScaleType === ScaleTypes.LABELS ||
            mainHorizontalScaleType === ScaleTypes.TIME) {
            result.domainAxisPosition = mainHorizontalAxisPosition;
            result.rangeAxisPosition = mainVerticalAxisPosition;
        }
        else if (mainVerticalScaleType === ScaleTypes.LABELS ||
            mainVerticalScaleType === ScaleTypes.TIME) {
            result.domainAxisPosition = mainVerticalAxisPosition;
            result.rangeAxisPosition = mainHorizontalAxisPosition;
        }
        else {
            result.domainAxisPosition = mainHorizontalAxisPosition;
            result.rangeAxisPosition = mainVerticalAxisPosition;
        }
        return result;
    };
    CartesianScales.prototype.getScaleDomain = function (axisPosition) {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", axisPosition);
        var includeZero = axisOptions.includeZero;
        var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
        if (this.model.isDataEmpty()) {
            return [];
        }
        var displayData = this.model.getDisplayData();
        var mapsTo = axisOptions.mapsTo, percentage = axisOptions.percentage;
        // If domain is specified return that domain
        if (axisOptions.domain) {
            if (scaleType === ScaleTypes.LABELS) {
                return axisOptions.domain;
            }
            return this.extendsDomain(axisPosition, axisOptions.domain);
        }
        // Return [0, 100] for percentage axis scale
        if (percentage) {
            return [0, 100];
        }
        // If scale is a LABELS scale, return some labels as the domain
        if (axisOptions && scaleType === ScaleTypes.LABELS) {
            // Get unique values
            return map(displayData, function (d) { return d[mapsTo]; }).keys();
        }
        // Get the extent of the domain
        var domain;
        var allDataValues;
        // If the scale is stacked
        if (axisOptions.stacked) {
            var dataValuesGroupedByKeys = this.model.getDataValuesGroupedByKeys();
            allDataValues = dataValuesGroupedByKeys.map(function (dataValues) {
                return sum(values(dataValues));
            });
        }
        else {
            allDataValues = displayData.map(function (datum) { return datum[mapsTo]; });
        }
        if (scaleType !== ScaleTypes.TIME && includeZero) {
            allDataValues.push(0);
        }
        domain = extent(allDataValues);
        domain = this.extendsDomain(axisPosition, domain);
        return domain;
    };
    CartesianScales.prototype.createScale = function (axisPosition) {
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", axisPosition);
        if (!axisOptions) {
            return null;
        }
        var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
        this.scaleTypes[axisPosition] = scaleType;
        var scale;
        if (scaleType === ScaleTypes.TIME) {
            scale = scaleTime();
        }
        else if (scaleType === ScaleTypes.LOG) {
            scale = scaleLog().base(axisOptions.base || 10);
        }
        else if (scaleType === ScaleTypes.LABELS) {
            scale = scaleBand();
        }
        else {
            scale = scaleLinear();
        }
        scale.domain(this.getScaleDomain(axisPosition));
        return scale;
    };
    CartesianScales.prototype.getHighestDomainThreshold = function () {
        var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
        var domainAxisPosition = this.getDomainAxisPosition();
        var thresholds = axesOptions[domainAxisPosition].thresholds;
        if (!thresholds) {
            return null;
        }
        var domainScale = this.getDomainScale();
        // Find the highest threshold for the domain
        var highestThreshold = thresholds.sort(function (a, b) { return b.value - a.value; })[0];
        var scaleType = this.getScaleTypeByPosition(domainAxisPosition);
        if (scaleType === ScaleTypes.TIME &&
            (typeof highestThreshold.value === "string" ||
                highestThreshold.value.getTime === undefined)) {
            highestThreshold.value = new Date(highestThreshold.value);
        }
        return {
            threshold: highestThreshold,
            scaleValue: domainScale(highestThreshold.value)
        };
    };
    CartesianScales.prototype.getHighestRangeThreshold = function () {
        var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
        var rangeAxisPosition = this.getRangeAxisPosition();
        var thresholds = axesOptions[rangeAxisPosition].thresholds;
        if (!thresholds) {
            return null;
        }
        var rangeScale = this.getRangeScale();
        // Find the highest threshold for the range
        var highestThreshold = thresholds.sort(function (a, b) { return b.value - a.value; })[0];
        return {
            threshold: highestThreshold,
            scaleValue: rangeScale(highestThreshold.value)
        };
    };
    return CartesianScales;
}(Service));
export { CartesianScales };
function addSpacingToTimeDomain(domain, spaceToAddToEdges) {
    var startDate = new Date(domain[0]);
    var endDate = new Date(domain[1]);
    if (differenceInYears(endDate, startDate) > 1) {
        return [
            subYears(startDate, spaceToAddToEdges),
            addYears(endDate, spaceToAddToEdges)
        ];
    }
    if (differenceInMonths(endDate, startDate) > 1) {
        return [
            subMonths(startDate, spaceToAddToEdges),
            addMonths(endDate, spaceToAddToEdges)
        ];
    }
    if (differenceInDays(endDate, startDate) > 1) {
        return [
            subDays(startDate, spaceToAddToEdges),
            addDays(endDate, spaceToAddToEdges)
        ];
    }
    if (differenceInHours(endDate, startDate) > 1) {
        return [
            subHours(startDate, spaceToAddToEdges),
            addHours(endDate, spaceToAddToEdges)
        ];
    }
    if (differenceInMinutes(endDate, startDate) > 30) {
        return [
            subMinutes(startDate, spaceToAddToEdges * 30),
            addMinutes(endDate, spaceToAddToEdges * 30)
        ];
    }
    if (differenceInMinutes(endDate, startDate) > 1) {
        return [
            subMinutes(startDate, spaceToAddToEdges),
            addMinutes(endDate, spaceToAddToEdges)
        ];
    }
    if (differenceInSeconds(endDate, startDate) > 15) {
        return [
            subSeconds(startDate, spaceToAddToEdges * 15),
            addSeconds(endDate, spaceToAddToEdges * 15)
        ];
    }
    if (differenceInSeconds(endDate, startDate) > 1) {
        return [
            subSeconds(startDate, spaceToAddToEdges),
            addSeconds(endDate, spaceToAddToEdges)
        ];
    }
    return [startDate, endDate];
}
function addSpacingToContinuousDomain(_a, paddingRatio) {
    var lower = _a[0], upper = _a[1];
    var domainLength = upper - lower;
    var padding = domainLength * paddingRatio;
    // If padding crosses 0, keep 0 as new upper bound
    var newUpper = upper <= 0 && upper + padding > 0 ? 0 : upper + padding;
    // If padding crosses 0, keep 0 as new lower bound
    var newLower = lower >= 0 && lower - padding < 0 ? 0 : lower - padding;
    return [newLower, newUpper];
}
//# sourceMappingURL=../../src/services/scales-cartesian.js.map