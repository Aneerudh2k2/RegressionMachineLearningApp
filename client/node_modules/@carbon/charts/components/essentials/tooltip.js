var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Component } from "../component";
import { Tools } from "../../tools";
import { DOMUtils } from "../../services";
// Carbon position service
import Position, { PLACEMENTS } from "@carbon/utils-position";
// import the settings for the css prefix
import settings from "carbon-components/es/globals/js/settings";
// D3 Imports
import { select, mouse } from "d3-selection";
import { Events, TruncationTypes } from "../../interfaces";
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "tooltip";
        _this.positionService = new Position();
        _this.init();
        return _this;
    }
    Tooltip.prototype.init = function () {
        var _this = this;
        // Grab the tooltip element
        var holder = select(this.services.domUtils.getHolder());
        var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
        this.tooltip = DOMUtils.appendOrSelect(holder, "div." + settings.prefix + "--" + chartprefix + "--tooltip");
        // Apply html content to the tooltip
        var tooltipTextContainer = DOMUtils.appendOrSelect(this.tooltip, "div.content-box");
        this.tooltip.style("max-width", null);
        // listen to move-tooltip Custom Events to move the tooltip
        this.services.events.addEventListener(Events.Tooltip.MOVE, function (e) {
            _this.positionTooltip(e);
        });
        // listen to show-tooltip Custom Events to render the tooltip
        this.services.events.addEventListener(Events.Tooltip.SHOW, function (e) {
            var data = e.detail.data;
            var defaultHTML = _this.getTooltipHTML(e);
            // if there is a provided tooltip HTML function call it
            if (Tools.getProperty(_this.model.getOptions(), "tooltip", "customHTML")) {
                tooltipTextContainer.html(_this.model
                    .getOptions()
                    .tooltip.customHTML(data, defaultHTML));
            }
            else {
                // Use default tooltip
                tooltipTextContainer.html(defaultHTML);
            }
            // Position the tooltip
            _this.positionTooltip(e);
            // Fade in
            _this.tooltip.classed("hidden", false);
        });
        // listen to hide-tooltip Custom Events to hide the tooltip
        this.services.events.addEventListener(Events.Tooltip.HIDE, function () {
            _this.tooltip.classed("hidden", true);
        });
    };
    Tooltip.prototype.getItems = function (e) {
        if (e.detail.items) {
            return e.detail.items;
        }
        return [];
    };
    Tooltip.prototype.formatItems = function (items) {
        var options = this.model.getOptions();
        // get user provided custom values for truncation
        var truncationType = Tools.getProperty(options, "tooltip", "truncation", "type");
        var truncationThreshold = Tools.getProperty(options, "tooltip", "truncation", "threshold");
        var truncationNumCharacter = Tools.getProperty(options, "tooltip", "truncation", "numCharacter");
        // truncate the label if it's too long
        // only applies to discrete type
        if (truncationType !== TruncationTypes.NONE) {
            return items.map(function (item) {
                if (item.label && item.label.length > truncationThreshold) {
                    item.label = Tools.truncateLabel(item.label, truncationType, truncationNumCharacter);
                }
                if (item.value && item.value.length > truncationThreshold) {
                    item.value = Tools.truncateLabel(item.value, truncationType, truncationNumCharacter);
                }
                return item;
            });
        }
        return items;
    };
    Tooltip.prototype.getTooltipHTML = function (e) {
        var defaultHTML;
        if (e.detail.content) {
            defaultHTML = "<div class=\"title-tooltip\">" + e.detail.content + "</div>";
        }
        else {
            var items = this.getItems(e);
            var formattedItems = this.formatItems(items);
            defaultHTML =
                "<ul class='multi-tooltip'>" +
                    formattedItems
                        .map(function (item) {
                        return "<li>\n\t\t\t\t\t\t\t<div class=\"datapoint-tooltip " + (item.bold ? "bold" : "") + "\">\n\t\t\t\t\t\t\t\t" + (item.color
                            ? '<a style="background-color: ' +
                                item.color +
                                '" class="tooltip-color"></a>'
                            : "") + "\n\t\t\t\t\t\t\t\t<p class=\"label\">" + item.label + "</p>\n\t\t\t\t\t\t\t\t<p class=\"value\">" + item.value + "</p>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>";
                    })
                        .join("") +
                    "</ul>";
        }
        return defaultHTML;
    };
    Tooltip.prototype.valueFormatter = function (value) {
        var options = this.model.getOptions();
        var valueFormatter = Tools.getProperty(options, "tooltip", "valueFormatter");
        if (valueFormatter) {
            return valueFormatter(value);
        }
        return value.toLocaleString();
    };
    Tooltip.prototype.render = function () {
        this.tooltip.classed("hidden", true);
    };
    Tooltip.prototype.positionTooltip = function (e) {
        var holder = this.services.domUtils.getHolder();
        var target = this.tooltip.node();
        var mouseRelativePos = Tools.getProperty(e, "detail", "mousePosition");
        if (!mouseRelativePos) {
            mouseRelativePos = mouse(holder);
        }
        var pos;
        // Find out whether tooltip should be shown on the left or right side
        var bestPlacementOption = this.positionService.findBestPlacementAt({
            left: mouseRelativePos[0],
            top: mouseRelativePos[1]
        }, target, [
            PLACEMENTS.RIGHT,
            PLACEMENTS.LEFT,
            PLACEMENTS.TOP,
            PLACEMENTS.BOTTOM
        ], function () { return ({
            width: holder.offsetWidth,
            height: holder.offsetHeight
        }); });
        var horizontalOffset = this.model.getOptions().tooltip.horizontalOffset;
        if (bestPlacementOption === PLACEMENTS.LEFT) {
            horizontalOffset *= -1;
        }
        // Get coordinates to where tooltip should be positioned
        pos = this.positionService.findPositionAt({
            left: mouseRelativePos[0] + horizontalOffset,
            top: mouseRelativePos[1]
        }, target, bestPlacementOption);
        this.positionService.setElement(target, pos);
    };
    return Tooltip;
}(Component));
export { Tooltip };
//# sourceMappingURL=../../../src/components/essentials/tooltip.js.map