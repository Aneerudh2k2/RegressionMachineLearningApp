var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Component } from "../component";
import { Tools } from "../../tools";
import { DOMUtils } from "../../services";
import { AxisPositions, Events, ScaleTypes } from "../../interfaces";
import { select, mouse } from "d3-selection";
// Carbon position service
import Position, { PLACEMENTS } from "@carbon/utils-position";
// import the settings for the css prefix
import settings from "carbon-components/es/globals/js/settings";
import { formatTick, computeTimeIntervalName } from "../../services/time-series";
var Threshold = /** @class */ (function (_super) {
    __extends(Threshold, _super);
    function Threshold(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "threshold";
        _this.positionService = new Position();
        return _this;
    }
    Threshold.prototype.render = function (animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        var _a = this.configs, value = _a.value, fillColor = _a.fillColor, axisPosition = _a.axisPosition, index = _a.index;
        var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
        this.thresholdClass = settings.prefix + "--" + chartprefix + "--threshold";
        // We can have multiple thresholds, set an unique identifier
        this.thresholdIdentifierClass = axisPosition + "-" + index;
        this.threshold = DOMUtils.appendOrSelect(this.parent, "g." + this.thresholdClass + "." + this.thresholdIdentifierClass).raise();
        // Append threshold hoverable area
        var thresholdRect = DOMUtils.appendOrSelect(this.threshold, "rect.threshold-hoverable-area");
        // Append threshold line
        var thresholdLine = DOMUtils.appendOrSelect(this.threshold, "line.threshold-line");
        // Set threshold line color from configs options
        // If not defined, the line takes the defined CSS color
        thresholdLine.style("stroke", fillColor);
        var scale = this.services.cartesianScales.getScaleByPosition(axisPosition);
        var scaleType = this.services.cartesianScales.getScaleTypeByPosition(axisPosition);
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var mainYScale = this.services.cartesianScales.getMainYScale();
        var isScaleTypeLabels = scaleType === ScaleTypes.LABELS;
        var _b = mainXScale.range(), xScaleStart = _b[0], xScaleEnd = _b[1];
        var _c = mainYScale.range(), yScaleEnd = _c[0], yScaleStart = _c[1];
        var cartesianScales = this.services.cartesianScales;
        var orientation = cartesianScales.getOrientation();
        var getDomainValue = function (d) { return cartesianScales.getDomainValue(d); };
        var getRangeValue = function (d) { return cartesianScales.getRangeValue(d); };
        var _d = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _d[0], getYValue = _d[1];
        if (axisPosition === AxisPositions.TOP ||
            axisPosition === AxisPositions.BOTTOM) {
            var position = getXValue(value) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            // Position the threshold on the x scale value
            this.threshold
                .transition(this.services.transitions.getTransition("threshold-update", animate))
                .attr("transform", "translate(" + position + ", " + yScaleStart + ")");
            // Set line end point on the y-axis
            thresholdLine.attr("y2", yScaleEnd - yScaleStart);
            // Set hoverable area width and rotate it
            thresholdRect
                .attr("width", yScaleEnd - yScaleStart)
                .classed("rotate", true);
        }
        else {
            var position = getYValue(value) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            // Position the threshold on the y scale value
            this.threshold
                .transition(this.services.transitions.getTransition("threshold-update", animate))
                .attr("transform", "translate(" + xScaleStart + ", " + position + ")");
            // Set line end point on the x-axis
            thresholdLine.attr("x2", xScaleEnd - xScaleStart);
            // Set hoverable area width
            thresholdRect.attr("width", xScaleEnd - xScaleStart);
        }
        var self = this;
        this.services.events.addEventListener(Events.Threshold.SHOW, function (e) {
            var hovered = e.detail.hoveredElement.node();
            // If is this threshold
            if (hovered === self.threshold) {
                // Set label position and show it
                _this.setThresholdLabelPosition();
                _this.label.classed("hidden", false);
            }
        });
        this.services.events.addEventListener(Events.Threshold.HIDE, function (e) {
            _this.label.classed("hidden", true);
        });
        this.appendThresholdLabel();
        this.addEventListeners();
    };
    Threshold.prototype.getFormattedValue = function () {
        var _a = this.configs, value = _a.value, axisPosition = _a.axisPosition;
        var options = this.model.getOptions();
        var scaleType = this.services.cartesianScales.getScaleTypeByPosition(axisPosition);
        // If scale is time, format the threshold date as the ticks format
        if (scaleType === ScaleTypes.TIME) {
            var isVertical = [
                AxisPositions.LEFT,
                AxisPositions.RIGHT
            ].includes(axisPosition);
            var mainXScale = this.services.cartesianScales.getMainXScale();
            var mainYScale = this.services.cartesianScales.getMainYScale();
            var scale = isVertical ? mainYScale : mainXScale;
            var timeScaleOptions = Tools.getProperty(options, "timeScale");
            var timeInterval = computeTimeIntervalName(scale.ticks());
            return formatTick(value, 0, timeInterval, timeScaleOptions);
        }
        return value.toLocaleString("en");
    };
    Threshold.prototype.appendThresholdLabel = function () {
        var _a = this.configs, value = _a.value, valueFormatter = _a.valueFormatter, fillColor = _a.fillColor, _b = _a.label, label = _b === void 0 ? "Threshold" : _b;
        var holder = select(this.services.domUtils.getHolder());
        // Format the threshold value using valueFormatter if defined in user-provided options
        var formattedValue = valueFormatter
            ? valueFormatter(value)
            : this.getFormattedValue();
        this.label = DOMUtils.appendOrSelect(holder, "div." + this.thresholdClass + "--label." + this.thresholdIdentifierClass);
        this.label
            .html(label + ": " + formattedValue)
            .classed("hidden", true)
            .style("background-color", fillColor);
    };
    Threshold.prototype.setThresholdLabelPosition = function () {
        var holder = this.services.domUtils.getHolder();
        var target = this.label.node();
        var mouseRelativePos = mouse(holder);
        // Find out whether threshold label should be shown on the left or right side
        var bestPlacementOption = this.positionService.findBestPlacementAt({
            left: mouseRelativePos[0],
            top: mouseRelativePos[1]
        }, target, [
            PLACEMENTS.RIGHT,
            PLACEMENTS.LEFT,
            PLACEMENTS.TOP,
            PLACEMENTS.BOTTOM
        ], function () { return ({
            width: holder.offsetWidth,
            height: holder.offsetHeight
        }); });
        // Get coordinates to where label should be positioned
        var pos = this.positionService.findPositionAt({
            left: mouseRelativePos[0],
            top: mouseRelativePos[1]
        }, target, bestPlacementOption);
        this.positionService.setElement(target, pos);
    };
    Threshold.prototype.addEventListeners = function () {
        var self = this;
        // Add events to the threshold hoverable area
        DOMUtils.appendOrSelect(this.threshold, "rect")
            .on("mouseover mousemove", function () {
            self.threshold.classed("active", true);
            self.services.events.dispatchEvent(Events.Threshold.SHOW, {
                hoveredElement: select(self.threshold)
            });
        })
            .on("mouseout", function () {
            self.threshold.classed("active", false);
            self.services.events.dispatchEvent(Events.Threshold.HIDE, {
                hoveredElement: select(self.threshold)
            });
        });
    };
    return Threshold;
}(Component));
export { Threshold };
//# sourceMappingURL=../../../src/components/essentials/threshold.js.map