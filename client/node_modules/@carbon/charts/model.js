// Internal Imports
import * as Configuration from "./configuration";
import { Tools } from "./tools";
import * as colorPalettes from "./services/colorPalettes";
import { Events, ScaleTypes } from "./interfaces";
// D3
import { scaleOrdinal } from "d3-scale";
import { map } from "d3-collection";
import { stack } from "d3-shape";
/** The charting model layer which includes mainly the chart data and options,
 * as well as some misc. information to be shared among components */
var ChartModel = /** @class */ (function () {
    function ChartModel(services) {
        // Internal Model state
        this.state = {
            options: {}
        };
        // Fill scales & fill related objects
        this.colorScale = {};
        this.services = services;
    }
    ChartModel.prototype.getAllDataFromDomain = function () {
        if (!this.get("data")) {
            return null;
        }
        var dataGroups = this.getDataGroups();
        // Remove datasets that have been disabled
        var displayData = Tools.clone(this.get("data"));
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        var axesOptions = this.getOptions().axes;
        // Check for custom domain
        if (axesOptions) {
            Object.keys(axesOptions).forEach(function (axis) {
                if (axesOptions[axis].mapsTo && axesOptions[axis].domain) {
                    var mapsTo_1 = axesOptions[axis].mapsTo;
                    if (axesOptions[axis].scaleType === ScaleTypes.LABELS) {
                        displayData = displayData.filter(function (datum) {
                            return axesOptions[axis].domain.includes(datum[mapsTo_1]);
                        });
                    }
                    else {
                        var _a = axesOptions[axis].domain, start_1 = _a[0], end_1 = _a[1];
                        // Filter out data outside domain
                        displayData = displayData.filter(function (datum) {
                            return datum[mapsTo_1] >= start_1 && datum[mapsTo_1] <= end_1;
                        });
                    }
                }
            });
        }
        return displayData.filter(function (datum) {
            return dataGroups.find(function (group) { return group.name === datum[groupMapsTo]; });
        });
    };
    ChartModel.prototype.getDisplayData = function () {
        if (!this.get("data")) {
            return null;
        }
        var ACTIVE = Configuration.legend.items.status.ACTIVE;
        var dataGroups = this.getDataGroups();
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        var allDataFromDomain = this.getAllDataFromDomain();
        return allDataFromDomain.filter(function (datum) {
            var group = dataGroups.find(function (group) { return group.name === datum[groupMapsTo]; });
            return group.status === ACTIVE;
        });
    };
    ChartModel.prototype.getData = function () {
        return this.get("data");
    };
    ChartModel.prototype.isDataEmpty = function () {
        return !this.getData().length;
    };
    /**
     *
     * @param newData The new raw data to be set
     */
    ChartModel.prototype.setData = function (newData) {
        var sanitizedData = this.sanitize(Tools.clone(newData));
        var dataGroups = this.generateDataGroups(sanitizedData);
        this.set({
            data: sanitizedData,
            dataGroups: dataGroups
        });
        return sanitizedData;
    };
    ChartModel.prototype.getDataGroups = function () {
        return this.get("dataGroups");
    };
    ChartModel.prototype.getActiveDataGroups = function () {
        var ACTIVE = Configuration.legend.items.status.ACTIVE;
        return this.getDataGroups().filter(function (dataGroup) { return dataGroup.status === ACTIVE; });
    };
    ChartModel.prototype.getDataGroupNames = function () {
        return this.getDataGroups().map(function (dataGroup) { return dataGroup.name; });
    };
    ChartModel.prototype.getActiveDataGroupNames = function () {
        return this.getActiveDataGroups().map(function (dataGroup) { return dataGroup.name; });
    };
    ChartModel.prototype.getGroupedData = function () {
        var displayData = this.getDisplayData();
        var groupedData = {};
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        displayData.map(function (datum) {
            var group = datum[groupMapsTo];
            if (groupedData[group] !== null &&
                groupedData[group] !== undefined) {
                groupedData[group].push(datum);
            }
            else {
                groupedData[group] = [datum];
            }
        });
        return Object.keys(groupedData).map(function (groupName) { return ({
            name: groupName,
            data: groupedData[groupName]
        }); });
    };
    ChartModel.prototype.getDataValuesGroupedByKeys = function () {
        var options = this.getOptions();
        var groupMapsTo = options.data.groupMapsTo;
        var displayData = this.getDisplayData();
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        var stackKeys = map(displayData, function (datum) { return datum[domainIdentifier]; }).keys();
        var axisPosition = this.services.cartesianScales.domainAxisPosition;
        var scaleType = options.axes[axisPosition].scaleType;
        // Sort keys
        if (scaleType === ScaleTypes.TIME) {
            stackKeys.sort(function (a, b) {
                var dateA = new Date(a);
                var dateB = new Date(b);
                return dateA - dateB;
            });
        }
        else if (scaleType === ScaleTypes.LOG ||
            scaleType === ScaleTypes.LINEAR) {
            stackKeys.sort(function (a, b) { return a - b; });
        }
        var dataGroupNames = this.getDataGroupNames();
        return stackKeys.map(function (key) {
            var correspondingValues = { sharedStackKey: key };
            dataGroupNames.forEach(function (dataGroupName) {
                var correspondingDatum = displayData.find(function (datum) {
                    return (datum[groupMapsTo] === dataGroupName &&
                        datum[domainIdentifier].toString() === key);
                });
                correspondingValues[dataGroupName] = correspondingDatum
                    ? correspondingDatum[rangeIdentifier]
                    : null;
            });
            return correspondingValues;
        });
    };
    ChartModel.prototype.getStackedData = function (_a) {
        var percentage = (_a === void 0 ? { percentage: false } : _a).percentage;
        var options = this.getOptions();
        var groupMapsTo = options.data.groupMapsTo;
        var dataGroupNames = this.getDataGroupNames();
        var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys();
        if (percentage) {
            var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function (d) { return [d.sharedStackKey, 0]; }));
            dataValuesGroupedByKeys.forEach(function (d) {
                dataGroupNames.forEach(function (name) {
                    maxByKey_1[d.sharedStackKey] += d[name];
                });
            });
            // cycle through data values to get percentage
            dataValuesGroupedByKeys.forEach(function (d) {
                dataGroupNames.forEach(function (name) {
                    d[name] = (d[name] / maxByKey_1[d.sharedStackKey]) * 100;
                });
            });
        }
        return stack()
            .keys(dataGroupNames)(dataValuesGroupedByKeys)
            .map(function (series, i) {
            // Add data group names to each series
            return Object.keys(series)
                .filter(function (key) { return !isNaN(key); })
                .map(function (key) {
                var element = series[key];
                element[groupMapsTo] = dataGroupNames[i];
                return element;
            });
        });
    };
    /**
     * @return {Object} The chart's options
     */
    ChartModel.prototype.getOptions = function () {
        return this.state.options;
    };
    ChartModel.prototype.set = function (newState, skipUpdate) {
        if (skipUpdate === void 0) { skipUpdate = false; }
        this.state = Object.assign({}, this.state, newState);
        if (!skipUpdate) {
            this.update();
        }
    };
    ChartModel.prototype.get = function (property) {
        if (property) {
            return this.state[property];
        }
        else {
            return this.state;
        }
    };
    /**
     *
     * @param newOptions New options to be set
     */
    ChartModel.prototype.setOptions = function (newOptions) {
        this.set({
            options: Tools.merge(this.getOptions(), newOptions)
        });
    };
    /**
     *
     * Updates miscellanous information within the model
     * such as the color scales, or the legend data labels
     */
    ChartModel.prototype.update = function () {
        if (!this.getDisplayData()) {
            return;
        }
        this.updateAllDataGroups();
        this.setColorScale();
        this.services.events.dispatchEvent(Events.Model.UPDATE);
    };
    ChartModel.prototype.setUpdateCallback = function (cb) {
        this.updateCallback = cb;
    };
    /*
     * Data labels
     */
    ChartModel.prototype.toggleDataLabel = function (changedLabel) {
        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;
        var dataGroups = this.getDataGroups();
        var hasDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });
        var activeItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });
        // If there are deactivated items, toggle "changedLabel"
        if (hasDeactivatedItems) {
            // If the only active item is being toggled
            // Activate all items
            if (activeItems.length === 1 &&
                activeItems[0].name === changedLabel) {
                // If every item is active, then enable "changedLabel" and disable all other items
                dataGroups.forEach(function (group, i) {
                    dataGroups[i].status = ACTIVE;
                });
            }
            else {
                var indexToChange = dataGroups.findIndex(function (group) { return group.name === changedLabel; });
                dataGroups[indexToChange].status =
                    dataGroups[indexToChange].status === DISABLED
                        ? ACTIVE
                        : DISABLED;
            }
        }
        else {
            // If every item is active, then enable "changedLabel" and disable all other items
            dataGroups.forEach(function (group, i) {
                dataGroups[i].status =
                    group.name === changedLabel ? ACTIVE : DISABLED;
            });
        }
        // Updates selected groups
        var updatedActiveItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });
        var options = this.getOptions();
        var hasUpdatedDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });
        // If there are deactivated items, map the item name into selected groups
        if (hasUpdatedDeactivatedItems) {
            options.data.selectedGroups = updatedActiveItems.map(function (activeItem) { return activeItem.name; });
        }
        else {
            // If every item is active, clear array
            options.data.selectedGroups = [];
        }
        // dispatch legend filtering event with the status of all the dataLabels
        this.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {
            dataGroups: dataGroups
        });
        // Update model
        this.set({
            dataGroups: dataGroups
        });
    };
    /**
     * Should the data point be filled?
     * @param group
     * @param key
     * @param value
     * @param defaultFilled the default for this chart
     */
    ChartModel.prototype.getIsFilled = function (group, key, data, defaultFilled) {
        var options = this.getOptions();
        if (options.getIsFilled) {
            return options.getIsFilled(group, key, data, defaultFilled);
        }
        else {
            return defaultFilled;
        }
    };
    ChartModel.prototype.getFillColor = function (group, key, data) {
        var options = this.getOptions();
        var defaultFillColor = this.getFillScale()(group);
        if (options.getFillColor) {
            return options.getFillColor(group, key, data, defaultFillColor);
        }
        else {
            return defaultFillColor;
        }
    };
    ChartModel.prototype.getStrokeColor = function (group, key, data) {
        var options = this.getOptions();
        var defaultStrokeColor = this.colorScale(group);
        if (options.getStrokeColor) {
            return options.getStrokeColor(group, key, data, defaultStrokeColor);
        }
        else {
            return defaultStrokeColor;
        }
    };
    ChartModel.prototype.getFillScale = function () {
        return this.colorScale;
    };
    /**
     * For charts that might hold an associated status for their dataset
     */
    ChartModel.prototype.getStatus = function () {
        return null;
    };
    /**
     * Converts data provided in the older format to tabular
     *
     */
    ChartModel.prototype.transformToTabularData = function (data) {
        console.warn("We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/tutorials--tabular-data-format");
        var tabularData = [];
        var datasets = data.datasets, labels = data.labels;
        // Loop through all datasets
        datasets.forEach(function (dataset) {
            // Update each data point to the new format
            dataset.data.forEach(function (datum, i) {
                var group;
                var datasetLabel = Tools.getProperty(dataset, "label");
                if (datasetLabel === null) {
                    var correspondingLabel = Tools.getProperty(labels, i);
                    if (correspondingLabel) {
                        group = correspondingLabel;
                    }
                    else {
                        group = "Ungrouped";
                    }
                }
                else {
                    group = datasetLabel;
                }
                var updatedDatum = {
                    group: group,
                    key: labels[i]
                };
                if (isNaN(datum)) {
                    updatedDatum["value"] = datum.value;
                    updatedDatum["date"] = datum.date;
                }
                else {
                    updatedDatum["value"] = datum;
                }
                tabularData.push(updatedDatum);
            });
        });
        return tabularData;
    };
    ChartModel.prototype.getTabularData = function (data) {
        // if data is not an array
        if (!Array.isArray(data)) {
            return this.transformToTabularData(data);
        }
        return data;
    };
    ChartModel.prototype.sanitize = function (data) {
        return this.getTabularData(data);
    };
    /*
     * Data groups
     */
    ChartModel.prototype.updateAllDataGroups = function () {
        // allDataGroups is used to generate a color scale that applies
        // to all the groups. Now when the data updates, you might remove a group,
        // and then bring it back in a newer data update, therefore
        // the order of the groups in allDataGroups matters so that you'd never
        // have an incorrect color assigned to a group.
        var _this = this;
        // Also, a new group should only be added to allDataGroups if
        // it doesn't currently exist
        if (!this.allDataGroups) {
            this.allDataGroups = this.getDataGroupNames();
        }
        else {
            // Loop through current data groups
            this.getDataGroupNames().forEach(function (dataGroupName) {
                // If group name hasn't been stored yet, store it
                if (_this.allDataGroups.indexOf(dataGroupName) === -1) {
                    _this.allDataGroups.push(dataGroupName);
                }
            });
        }
    };
    ChartModel.prototype.generateDataGroups = function (data) {
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;
        var options = this.getOptions();
        var uniqueDataGroups = map(data, function (datum) { return datum[groupMapsTo]; }).keys();
        // check if selectedGroups can be applied to chart with current data groups
        if (options.data.selectedGroups.length) {
            var hasAllSelectedGroups = options.data.selectedGroups.every(function (groupName) { return uniqueDataGroups.includes(groupName); });
            if (!hasAllSelectedGroups) {
                options.data.selectedGroups = [];
            }
        }
        // Get group status based on items in selected groups
        var getStatus = function (groupName) {
            return !options.data.selectedGroups.length ||
                options.data.selectedGroups.includes(groupName)
                ? ACTIVE
                : DISABLED;
        };
        return uniqueDataGroups.map(function (groupName) { return ({
            name: groupName,
            status: getStatus(groupName)
        }); });
    };
    /*
     * Fill scales
     */
    ChartModel.prototype.setColorScale = function () {
        var defaultColors = colorPalettes.DEFAULT;
        var options = this.getOptions();
        var userProvidedScale = Tools.getProperty(options, "color", "scale");
        // If there is no valid user provided scale, use the default set of colors
        if (userProvidedScale === null ||
            Object.keys(userProvidedScale).length === 0) {
            this.colorScale = scaleOrdinal()
                .range(defaultColors)
                .domain(this.allDataGroups);
            return;
        }
        /**
         * Go through allDataGroups. If a data group has a color value provided
         * by the user, add that to the color range
         * If not, add a default color
         */
        var colorRange = [];
        var colorIndex = 0;
        this.allDataGroups.forEach(function (dataGroup) {
            if (userProvidedScale[dataGroup]) {
                colorRange.push(userProvidedScale[dataGroup]);
            }
            else {
                colorRange.push(defaultColors[colorIndex]);
            }
            if (colorIndex === defaultColors.length - 1) {
                colorIndex = 0;
            }
            else {
                colorIndex++;
            }
        });
        this.colorScale = scaleOrdinal()
            .range(colorRange)
            .domain(this.allDataGroups);
    };
    return ChartModel;
}());
export { ChartModel };
//# sourceMappingURL=../src/model.js.map